{"cells":[{"cell_type":"code","execution_count":6,"metadata":{"executionInfo":{"elapsed":771,"status":"ok","timestamp":1770766826523,"user":{"displayName":"David Leifer","userId":"06279506333224389759"},"user_tz":360},"id":"IxtfVwAjhyaV","colab":{"base_uri":"https://localhost:8080/","height":1000},"outputId":"9949781c-db6b-4089-e301-4b57c3876c8f"},"outputs":[{"output_type":"display_data","data":{"text/plain":["<Figure size 800x600 with 1 Axes>"],"image/png":"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RS2rA/zT2rVr9fHHH2vevHny9vZW6dKldejQoUzPZ+t0g4cfflhBQUH66KOP1LhxY23btk2vv/76HY/LqJ/SpUtry5YtatSoUZpgl5769eurfv36euONN7Rs2TL17NlTK1as0LPPPmvTddyWmpqq+Ph4SbeCc4ECBZSampphELyTUqVK6ciRI2nab791X6pUqUyPL126tCTJ19f3rmu4kx07dujSpUtau3atHn74YUv7P0f6Adz/mDMLIMfduHFDa9euVbt27dS5c+c0X0OGDFFcXJzWr18vSerUqZN++uknffzxx2nOdXsELV++fJJujdZlhYuLizp37qxPP/1UixcvVkpKSpamGGTUz1NPPaXU1FRNmDAhzTEpKSmW/a9cuZJm1O/2yGViYmKWav+37du3Kz4+3jKq7Orqqk6dOmnNmjXp/hJwe25tZh577DF999132rNnj6Xt+vXrmj9/vkJDQ1WpUqVMj69Vq5ZKly6tt956yxKyba3hTm6Pqv7z+UxKStLcuXPv+dwAnAcjswBy3Pr16xUXF6cOHTqku71+/foKCAjQ0qVL1bVrV/33v//V6tWr1aVLF/Xr10+1atXS5cuXtX79es2bN0/Vq1dX6dKl5efnp3nz5qlAgQLKly+f6tWrl2Yu5z917dpV//vf/zRu3DhVrVrVMh80M7Vq1ZIkDR06VK1bt5arq6u6deumJk2aaODAgZo8ebIOHDigVq1ayd3dXceOHdOqVas0e/Zsde7cWR988IHmzp2rJ598UqVLl1ZcXJz+7//+T76+vnrsscfu2P+1a9csd+pKSUnRkSNH9O6778rb21uvvvqqZb8pU6Zo+/btqlevnp577jlVqlRJly9f1g8//KAtW7bo8uXLmfbz6quvavny5WrTpo2GDh0qf39/ffDBBzp58qTWrFlzxxsiuLi4aMGCBWrTpo0qV66svn37qnjx4jp9+rS2b98uX19fffrpp3e83sw0bNhQhQoVUu/evTV06FCZTCYtXryYKQJAXuPAlRQA5FHt27c3vLy8jOvXr2e4T58+fQx3d3fL0lKXLl0yhgwZYhQvXtzw8PAwSpQoYfTu3dtq6alPPvnEqFSpkuHm5ma1pNa/l2W6zWw2GyEhIYYkY+LEiWm2p7c0V0pKivHiiy8aAQEBhslkSrNM1/z5841atWoZ3t7eRoECBYyqVasa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SJ+2coYaJeep0x7y8rUDABwrp1+DYmNjVaRIkSyFWZunGaSmpmrRokXaunWrzp8/L7PZbLV927Zttp7Sws/PT+XKldPvv/+e7vYxY8bomWee0bPPPitJqlq1qq5fv64BAwbo9ddfT/emDp6envL09EzT7u7unuOBwBF92soZapScp057yMvXDgBwrJx6DbKlD5vD7LBhw7Ro0SK1bdtWVapUyfAmCncjPj5ex48fz3AObEJCQprA6urqKombNgAAAORFNofZFStWaOXKlXrsscfuufORI0eqffv2KlWqlM6cOaNx48bJ1dVV3bt3lyT16tVLxYsX1+TJkyVJ7du314wZM1SzZk3LNIMxY8aoffv2llALAACAvMPmMOvh4aEyZcpkS+enTp1S9+7ddenSJQUEBKhx48bau3evAgICJEnR0dFWI7GjR4+WyWTS6NGjdfr0aQUEBKh9+/Z64403sqUeAAAAOBebw+x//vMfzZ49W2+//fY9TzFYsWJFptt37Nhh9djNzU3jxo3TuHHj7qlfAAAA3B9sDrO7d+/W9u3btXHjRlWuXDnNBN21a9dmW3EAAABAZmwOs35+fnryySftUQsAAABgE5vDbGRkpD3qAAAAAGyWdmFWAAAAwEnYPDIrSatXr9bKlSsVHR2tpKQkq20//PBDthQGAAAA3InNI7Nz5sxR3759VaxYMf3444+qW7euChcurBMnTqhNmzb2qBEAAABIl81hdu7cuZo/f77+97//ycPDQy+//LI2b96soUOH6tq1a/aoEQAAAEiXzWE2OjpaDRs2lCR5e3srLi5OkvTMM89o+fLl2VsdAAAAkAmbw2xgYKAuX74sSSpZsqT27t0rSTp58qQMw8je6gAAAIBM2BxmmzdvrvXr10uS+vbtq+HDh6tly5bq2rUr688CAAAgR9m8msH8+fNlNpslSYMHD1bhwoX1zTffqEOHDho4cGC2FwgAAABkxOYw6+LiIheXvwd0u3Xrpm7dumVrUQAAAEBW3NVNE7766is9/fTTatCggU6fPi1JWrx4sXbv3p2txQEAAACZsTnMrlmzRq1bt5a3t7d+/PFHJSYmSpKuXbumSZMmZXuBAAAAQEZsDrMTJ07UvHnz9H//939yd3e3tDdq1Ii7fwEAACBH2Rxmjxw5oocffjhNe8GCBXX16tXsqAkAAADIkrtaZ/b3339P075792498MAD2VIUAAAAkBU2h9nnnntOw4YN07fffiuTyaQzZ85o6dKlGjlypF544QV71AgAAACky+aluV599VWZzWY98sgjSkhI0MMPPyxPT0+NHDlSL774oj1qBAAAANJlc5g1mUx6/fXX9d///le///674uPjValSJeXPn98e9QEAAAAZsjnM3ubh4aFKlSplZy0AAACATbIcZvv165el/d5///27LgYAAACwRZbD7KJFi1SqVCnVrFlThmHYsyYAAAAgS7IcZl944QUtX75cJ0+eVN++ffX000/L39/fnrUBAAAAmcry0lzvvPOOYmJi9PLLL+vTTz9VSEiInnrqKW3atImRWgAAADiETevMenp6qnv37tq8ebMOHz6sypUra9CgQQoNDVV8fLy9agQAAADSZfNNEywHurjIZDLJMAylpqZmZ00AAABAltgUZhMTE7V8+XK1bNlS5cqV088//6y3335b0dHRrDMLAACAHJflD4ANGjRIK1asUEhIiPr166fly5erSJEi9qwNAAAAyFSWw+y8efNUsmRJPfDAA9q5c6d27tyZ7n5r167NtuIAAACAzGQ5zPbq1Usmk8metQAAAAA2semmCQAAAEBucterGQAAAACORpgFAACA0yLMAgAAwGkRZgEAAOC0CLMAAABwWoRZAAAAOC3CLAAAAJwWYRYAAABOizALAAAAp0WYBQAAgNMizAIAAMBpEWYBAADgtAizAAAAcFoODbPh4eEymUxWXxUqVMj0mKtXr2rw4MEKCgqSp6enypUrpw0bNuRQxQAAAMhN3BxdQOXKlbVlyxbLYze3jEtKSkpSy5YtVbRoUa1evVrFixfXH3/8IT8/vxyoFAAAALmNw8Osm5ubAgMDs7Tv+++/r8uXL+ubb76Ru7u7JCk0NNSO1QEAACA3c3iYPXbsmIKDg+Xl5aUGDRpo8uTJKlmyZLr7rl+/Xg0aNNDgwYP1ySefKCAgQD169NArr7wiV1fXdI9JTExUYmKi5XFsbKwkKTk5WcnJydl/Qem43U9O9Xc3nKFGyXnqtIe8fO0AAMfK6dcgW/oxGYZh2LGWTG3cuFHx8fEqX768YmJiFBERodOnT+vQoUMqUKBAmv0rVKigqKgo9ezZU4MGDdLvv/+uQYMGaejQoRo3bly6fYSHhysiIiJN+7Jly+Tj45Pt1wQAAIB7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\n"},"metadata":{}},{"output_type":"display_data","data":{"text/plain":["<Figure size 800x600 with 1 Axes>"],"image/png":"iVBORw0KGgoAAAANSUhEUgAAAqYAAAIzCAYAAADS0NtvAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjAsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvlHJYcgAAAAlwSFlzAAAPYQAAD2EBqD+naQAA7bhJREFUeJzs3Xd8VGXWwPHfnZLeSEhPCJDQQkIHEUFFEFCxK6iLgrrKWtbCrn1fe8NVLGvD3hULdkFBsaOAlNBLCAHSCel9Zu77x50Z0utMZiY5388Hzdy5ufdkCJOT53nOeRRVVVWEEEIIIYRwMZ2rAxBCCCGEEAIkMRVCCCGEEG5CElMhhBBCCOEWJDEVQgghhBBuQRJTIYQQQgjhFiQxFUIIIYQQbkESUyGEEEII4RYkMRVCCCGEEG5BElMhhBBCCOEWJDEVQri9BQsW0L9//w5/3oEDB1AUhTfeeKNd5yuKwr333tvh+7ijlStXMmrUKHx8fFAUheLiYleH5HA96e9LCKGRxFQI0WXPP/88iqJw3HHHdfoa2dnZ3HvvvWzevNlxgTXjm2++cZtkxpY41/8TFBTEqFGjePbZZzGbzZ26bmFhIXPmzMHX15fnnnuOt99+G39/fwdH33H33ntvg6/Vz8+P5ORk/vOf/1BaWurq8IQQbsDg6gCEEJ7v3XffpX///qxbt459+/aRlJTU4WtkZ2dz33330b9/f0aNGtXguZdffhmLxdLhayYkJFBVVYXRaLQf++abb3juueeaTU6rqqowGLr/bfHiiy/m9NNPB6CkpIRvvvmGf/7zn2RmZvLf//63w9dbv349ZWVlPPDAA0yfPt3R4XbZCy+8QEBAAOXl5Xz33Xc89NBD/PDDD/z2228oitLu67jq70sI4TwyYiqE6JKMjAx+//13lixZQnh4OO+++67D72E0GvH29u7w5ymKgo+PD3q9vl3n+/j4uCTRGTNmDPPmzWPevHlcd911fPXVV4wfP5733nuvU9fLz88HICQkxGExVlRUOOxaF1xwAfPmzeMf//gHy5cv57zzzmPt2rX88ccfHbqOq/6+hBDOI4mpEKJL3n33Xfr06cMZZ5zBBRdc0GJiWlxczM0330z//v3x9vYmLi6Oyy67jCNHjvDjjz8yfvx4AC6//HL7VK9tbWj9NaZ1dXWEhoZy+eWXN7lHaWkpPj4+/Pvf/waarjFdsGABzz33HECDKWWb5tYsZmVlccUVVxAZGYm3tzfDhw/ntddea3Lv//3vfwwfPhw/Pz/69OnDuHHjOp1YKopCZGRks0nXihUrmDJlCv7+/gQGBnLGGWewfft2+/Mnn3wy8+fPB2D8+PEoisKCBQvsz3/00UeMHTsWX19f+vbty7x588jKympwjwULFhAQEEB6ejqnn346gYGB/O1vfwPAYrHw1FNPMXz4cHx8fIiMjGThwoUUFRV16msFOOWUUwDtl5za2lruvvtuxo4dS3BwMP7+/kyZMoU1a9Y0+zrV//uyLRXYt28fCxYsICQkhODgYC6//HIqKys7HZ8QovvIr5pCiC559913Oe+88/Dy8uLiiy/mhRdeYP369fZEE6C8vJwpU6awc+dOrrjiCsaMGcORI0f44osvOHz4MMOGDeP+++/n7rvv5uqrr2bKlCkATJo0qcn9jEYj5557LsuXL2fp0qV4eXnZn/vss8+oqanhoosuajbWhQsXkp2dzapVq3j77bfb/Nry8vKYOHEiiqJw/fXXEx4ezooVK7jyyispLS3lpptuArSlBjfccAMXXHABN954I9XV1aSlpfHnn39yySWXtHmfyspKjhw5AmjJ9YoVK1i5ciV33HFHg/Pefvtt5s+fz8yZM1m8eDGVlZW88MILTJ48mU2bNtG/f3/uuusuhgwZwksvvcT999/PgAEDSExMBOCNN97g8ssvZ/z48TzyyCPk5eXx9NNP89tvv7Fp06YGI6wmk4mZM2cyefJkHn/8cfz8/Oyvoe06N9xwAxkZGTz77LNs2rSJ3377rcGyifZKT08HICwsjNLSUl555RUuvvhirrrqKsrKynj11VeZOXMm69ata7LMozlz5sxhwIABPPLII2zcuJFXXnmFiIgIFi9e3OHYhBDdTBVCiE7asGGDCqirVq1SVVVVLRaLGhcXp954440Nzrv77rtVQF2+fHmTa1gsFlVVVXX9+vUqoL7++utNzpk/f76akJBgf/ztt9+qgPrll182OO/0009XBw4caH+ckZHR5JrXXXed2tJbH6Dec8899sdXXnmlGh0drR45cqTBeRdddJEaHBysVlZWqqqqqmeffbY6fPjwZq/ZGlt8zf255ppr7K+NqqpqWVmZGhISol511VUNrpGbm6sGBwc3OP7666+rgLp+/Xr7sdraWjUi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L1+OXbt24dlnn/X4m6R169YYOXIk3n77bde/f2N0797dtYSIYvPmzejRo4enIvJ5dfL083ox/vp5YLPZsHDhQrz++uu1fskkJibiiy++cB27detW1+2ioiIcOnTIrdc9JSUFkydPxtKlS/Hkk0/ivffe8+rPohgwYAD27dtX6xdrp06doNfrceDAARQWFmL27NkYNmwYunXrptqo1IVmz56N77//Hlu2bGlw3t69e8PhcGDDhg1eyVgTX7fq8dfntiH8+T2muKwL08LCQlx//fX47LPPkJ6ejmPHjuGrr77CP//5T4wfPx6A3B2/du1a5OXl+dWSIVarFXl5ecjLy8P+/fvx2GOPoaysDOPGjUOnTp2QkpKC559/HocPH8YPP/yA119/3e3727Vrh7KyMqxduxZnz571+DqSSjGyYMECVFRUuN2Xl5eHzz//HPfffz8AICYmxq2IPnz4sFueX3/9FW3btsWzzz6LQYMGoXPnzqpdsrBgwQLYbDYMGjQIS5Yswf79+3Hw4EF89tlnOHDgALRabb3f+7e//Q0ff/wx/v3vf+Pw4cOYO3culi5diunTp3ssH59XdZ5XIPA+D5YvX46ioiI88MAD6NWrl9uf2267zW1Y9IUXXsDatWuRmZmJ+++/H9HR0a71DqdOnYqffvoJx44dQ1paGn7++ed6LxVR29NPP41ff/0Vjz76KHbv3o3Dhw/ju+++w6OPPgoAaNOmDfR6Pd566y0cPXoUy5Ytw4svvuiVbL1798bdd9+NN998s8F527Vrh4kTJ2LSpEn49ttvcezYMaxfv96jl8vwdave6zbQntuG8Of3mItXrmT1U5WVleLvf/+7GDBggIiIiBAmk0l07dpVPPfcc64Zz8uWLROdOnUSOp2u1lIQNdU1G2748OFiypQpHs89ceJEtyUqwsLCxBVXXCH+97//uY7ZtGmT6N27tzAajWLYsGHiq6++cpv8JIQQkydPFq1bt1ZtuahDhw6J6OhoMWzYMLFhwwZx8uRJsWLFCtGrVy/Rr18/14XUf/zjH0X37t1FWlqa2L59u7j++utFUFCQa5LOd999J3Q6nfjiiy/EkSNHxPz580VUVJRqk7dycnLEo48+Ktq3by+CgoJEaGioGDx4sPjXv/4lysvLhRB1X/AuhHeWNeLzqs7zGmifB2PHjq13Athvv/0mAIj58+cLAOL7778XPXv2FHq9XgwePNht8sajjz4qOnbsKAwGg4iJiRH33nuvOHv2rMdyKhq6lM22bdvEyJEjRWhoqAgJCRF9+vRxW0po0aJFol27dsJgMIghQ4aIZcuWCQBi165dquc9duyY0Ov1bstFXSpvRUWFeOKJJ0RCQoLQ6/WiU6dO4sMPP/RYTr5u1XvdBtpzG2jvsfpc1oUpqe/YsWNi4sSJIi4uTkiSJACI3//+965CRAghsrOzxahRo0RISIjo3Lmz+PHHH2vNHv/b3/4mWrduLUJDQ8Wdd94p3njjDVVXFfB3fF6JiKglkoS4xCwKIg+aOXMm5s6di9WrV+Oqq67ydZwWg88rERG1BCxMyes++ugjlJSU4PHHH3dbOoOah88rEREFOhamREREROQX2K1CRERERH6BhSkRERER+QUWpkRERETkF1iYOtntdvzf//0f2rdvj+DgYHTs2BEvvvhinVs/jhgxwm3vWUBeiDc5ORmSJKG4uJh5m5n1448/hiRJdf5RcxcKf87a1H/zxx9/HAMHDoTBYEC/fv3qfOz09HQMGzYMRqMRKSkp+Oc//+m3edevX4/x48cjISEBISEh6NevHz7//HOvZ92zZw/uuusupKSkIDg4GN27d8f8+fNrHf/OO++ge/fuCA4ORteuXbFw4UKvZy0sLMTo0aORmJgIg8GAlJQUPProozCbza5jc3NzMWHCBHTp0gUajQZTp05tVs6LKS0txdSpU9G2bVsEBwdj6NCh2L59e735vfl50NhswKVfs5WVlbj//vvRu3dv6HQ61yLx/pj14MGDGDFiBOLi4mA0GtGhQwc899xzHtnWOpDyNjZrQz4P1HqPqZF1/fr1db7f8vLyPJL5onyxRpU/evnll0Xr1q3F8uXLxbFjx8RXX30lQkNDxfz5892OKywsFEFBQSIvL8+tffz48eKmm25yW8SWeZue1WKxiNzcXLc/qampYvjw4Zdt1qb+mz/22GPi7bffFvfee2+tRZ+FEKKkpETExcWJu+++W2RmZoovvvhCBAcHi//85z9+mffll18Wzz33nNi8ebM4cuSImDdvntBoNOL777/3atYPPvhAPP7442L9+vUiKytLfPrppyI4OFi89dZbruMXLFggwsLCxOLFi0VWVpb44osvRGhoqFi2bJlXs547d04sWLBAbN++XRw/flysWbNGdO3aVdx1112u448dOyYef/xx8cknn4h+/fqpsjmI4o477hA9evQQGzZsEIcPHxYzZ84U4eHh4vTp03Xm9+bnQWOzCXHp12xZWZmYPHmy+O9//ytSU1PrXATdX7JmZWWJDz/8UOzevVscP35cfPfddyI2NlbMmDHjssrb2KwN+TxQ6z2mRlZlUf6DBw+6ve/sdrtHMl8MC1Onm2++WUyaNMmt7fe//724++673doWLlworrzySre2BQsWiOHDh4u1a9d6rTANpLzNyaooKCgQQUFBquz4U5M/Z21utrp2IxFCfj20atVKWK1WV9vTTz8tunbt6pd56zJmzBjxpz/9yWdZFX/961/FiBEjXF8PGTJETJ8+3e2YadOmiauvvtrnWefPny+Sk5PrvE+tXeuEEMJisQitViuWL1/u1j5gwADx7LPPur72xXusudka8pqtb3cef8yqeOKJJ8Q111xz2eT1xGtUiNqfBzV56j2mVtYLd4vyJg7lOw0dOhRr167FoUOHAAB79uzBpk2bcNNNN7kdt2zZMtceuQCwb98+vPDCC1i4cKFX144MpLxNzVrTwoULYTKZ8Ic//OGyzeqJbHXZsmULrr32Wuj1eldbamoqDh482Ky9n9XKW5eSkhJERUX5POuFOaxWK4xGo9sxwcHB2LZtW5OHGj2RNScnB0uXLsXw4cOblKE5bDYb7HZ7nc/Lpk2bXF/74j3miWze4q2sR44cwcqVK5v9WgmkvJ7K2tzPpYZQO2u/fv2QkJCAkSNHYvPmzZ4LfjFeL4X9lN1uF08//bSQJEnodDohSZJ45ZVX3I6prKwUoaGhIjMz0/V1nz59xKeffiqE8O7/MAIpb1OyXqh79+7i4YcfVjWnv2dtbrb6ehxGjhwpHnzwQbe2vXv3CgBi3759fpf3QkuWLBF6vb7efw9vZBVCiM2bNwudTid++uknV9uMGTNEfHy82LFjh3A4HGL79u0iLi5OABA5OTlez/rHP/5RBAcHCwBi3LhxoqKios5zqNljKoTckzx8+HCRnZ0tbDab+PTTT4VGoxFdunS5aH6Fmp8HzcnmzR5TtbMOGTJEGAwGAUA8+OCDHhnCDaS8zX2N1vV5UJMn32NqZD1w4IB49913xY4dO8TmzZvFn/70J6HT6cTOnTs9kvliWJg6ffHFFyI5OVl88cUXIj09XSxcuFBERUWJjz/+2HXMjz/+KDp06OD6+oknnhB33nmn62tvFqaBlLcpWWv69ddfBQCxY8cOVXP6e9bmZvN2YapW3prWrVsnTCaT+OSTT5qc0xNZMzIyRHR0tHjxxRfd2i0Wi+sDXavVisTERPHUU08JALWu+/ZG1tzcXLF//37x3XffiR49etRb3KldmB45ckRce+21AoDQarXiiiuuEHfffbfo1q3bRfMLof7nQXOyebswVTPryZMnxd69e8WiRYtEUlKSmDNnzmWVtzlZ6/s8qMmT7zG1syquvfZacc8993gk88WwMHVKTk4Wb7/9tlvbiy++6Had3eTJk8XUqVNdX/ft21doNBqh1WqFVqsVGo3G9cL4xz/+wbzNyFrTpEmTRL9+/VTLV5M/Z21utvo+2O+9995avyjXrVsnAIhz5875XV7F+vXrRUhISLMnaTU36969e0VsbKx45pln6n38qqoqcerUKWGz2VwToprao9Pc51WxcePGentu1S5MFWVlZa7z33HHHWLMmDFCCP/4PGhKNm8Xpgq1siqUyTE2m+2yy9vYrA35PBBCnfeYWlkV06dPF1dddZXnAteD15g6WSyWWtdcarVaOBwOAIAQAt9//73bNRpff/019uzZg927d2P37t2u5S02btyIRx55hHmbkVVRVlaGL7/8Eg888IBq+QIla3OyXcyQIUPwyy+/uF3zuHr1anTt2hWtWrXyu7yAvJTJzTffjDlz5uDBBx9scsbmZt27dy9GjBiBiRMn4uWXX6738YOCgpCcnAytVovFixdj7NixTb7G21PPq3K81WptUg5PCAkJQUJCAoqKivDTTz9h/PjxfvN50NhsvqR2VofDgerqatdrprkCKW9jsjb080AtamfdvXs3EhIS1IjuTvXSN0BMnDhRJCUluZZgWbp0qYiOjhZPPfWUEEKI7du3i1atWonq6up6H8ObQ/mBlLc5Wd9//31hNBq9NjPQn7M2Ndvhw4fFrl27xEMPPSS6dOkidu3aJXbt2uWahV9cXCzi4uLEvffeKzIzM8XixYuFyWRqdk+kWnmV4fsZM2a4LWNSWFjo1awZGRkiJiZG3HPPPW45CgoKXMccPHhQfPrpp+LQoUPit99+E3feeaeIiooSx44d82rWH374QXz44YciIyNDHDt2TCxfvlx079691uoAynM9cOBAMWHCBLFr1y6xd+/eJmetz8qVK8WKFSvE0aNHxapVq0Tfvn3FlVdeKaqqqnz+edCUbJd6zQoh907t2rVLjBs3Tlx33XWuY/wt62effSaWLFki9u3bJ7KyssSSJUtEYmJirVUfWnrexmZtyOeBEOq8x9TI+sYbb4hvv/1WHD58WGRkZIgpU6YIjUYj1qxZ06ysDcHC1MlsNospU6aINm3aCKPRKDp06CCeffZZ14v/ueeeu+QL3ZuFaSDlbU7WIUOGiAkTJqiaL1CyNjXb8OHDBYBaf2oWR3v27BHXXHONMBgMIikpScyePdtv806cOLHO+5uzpmVTss6cObPOHG3btnUds2/fPtGvXz8RHBwswsPDxfjx48WBAweanLOpWdetWyeGDBkiIiIihNFoFJ07dxZPP/10rff+pX4eT1myZIno0KGD0Ov1Ij4+XjzyyCOiuLi43vwKb3weNCVbQ95jbdu2rfMYf8u6ePFiMWDAABEaGipCQkJEjx49xCuvvFLvRLmWmrexWRvyeSCEOu8xNbLOmTNHdOzYURiNRhEVFSWuu+46sW7dumblbCgWpg3Uu3dvsWTJEl/HaLBAysusnuHP2eoSSHmZ1Xv8Ob8/Z7tQIGUVIrDyMqu6eI1pA1RVVeG2226rtU6gvwqkvMzqGf6crS6BlJdZvcef8/tztgsFUlYgsPIyq/okIerYYJmIiIiIyMvYY0pEREREfoGFKRERERH5BRamREREROQXWJgSERERkV9gYUpEREREfoGFKRGRn1i7di26d+8Ou93u6yi1vPvuuxg3bpyvYxBRC8fClIguK/fffz8kSYIkSQgKCkJcXBxGjhyJDz/8sNF7a3/88ceIjIz0WLannnoKzz33HLRaLQBg6dKlGDlyJGJiYhAeHo4hQ4bgp59+qvV977zzDtq1awej0Ygrr7wS27Ztc9137tw5PPbYY+jatSuCg4PRpk0bPP744ygpKakzQ2FhIZKTkyFJEoqLi13tkyZNQlpaGjZu3Oixn5eI6EIsTInosjN69Gjk5ubi+PHjWLFiBUaMGIEpU6Zg7NixsNlsPsm0adMmZGVl4bbbbnO1/fLLLxg5ciR+/PFH7Ny5EyNGjMC4ceOwa9cu1zFLlizBtGnTMHPmTKSlpaFv375ITU1FQUEBACAnJwc5OTl47bXXkJmZiY8//hgrV67EAw88UGeOBx54AH369KnVrtfrMWHCBLz55pse/smJiGrw9dZTRETeNHHiRDF+/Pha7WvXrhUAxHvvvedqe/3110WvXr2EyWQSycnJ4uGHHxalpaVCCCF+/vnnWntNz5w5UwghRGVlpXjyySdFYmKiMJlMYvDgweLnn3++aK5HHnlE/OEPf7hk/h49eohZs2a5vh48eLB45JFHXF/b7XaRmJgoXn311Xof48svvxR6vV5UV1e7tS9YsEAMHz7c9VwUFRW53b9hwwah1+uFxWK5ZE4ioqZgjykREYDrr78effv2xdKlS11tGo0Gb775Jvbu3YtPPvkE69atw1NPPQUAGDp0KObNm4fw8HDk5uYiNzcX06dPBwA8+uij2LJlCxYvXoz09HTcfvvtGD16NA4fPlzv+Tdu3IhBgwZdNKPD4UBpaSmioqIAyFsO7ty5EzfeeKNb5htvvBFbtmyp93FKSkoQHh4OnU7natu3bx9eeOEFLFy4EBpN3b8aBg0aBJvNht9+++2iOYmImoqFKRGRU7du3XD8+HHX11OnTsWIESPQrl07XH/99XjppZfw5ZdfApCHtiMiIiBJEuLj4xEfH4/Q0FCcPHkSH330Eb766isMGzYMHTt2xPTp03HNNdfgo48+qvfcJ06cQGJi4kXzvfbaaygrK8Mdd9wBADh79izsdjvi4uLcjouLi0NeXl6dj3H27Fm8+OKLePDBB11tVqsVd911F/71r3+hTZs29Z7fZDIhIiICJ06cuGhOIqKm0l36ECKiy4MQApIkub5es2YNXn31VRw4cABmsxk2mw2VlZWwWCwwmUx1PkZGRgbsdju6dOni1m61WtG6det6z11RUQGj0Vjv/YsWLcKsWbPw3XffITY2tpE/mcxsNuPmm29Gjx498Pzzz7vaZ8yYge7du+Oee+655GMEBwfDYrE06fxERJfCwpSIyGn//v1o3749AOD48eMYO3YsHn74Ybz88suIiorCpk2b8MADD6CqqqrewrSsrAxarRY7d+50za5XhIaG1nvu6OhoFBUV1Xnf4sWL8ec//xlfffWV27B9dHQ0tFot8vPz3Y7Pz89HfHy8W1tpaSlGjx6NsLAwfPPNNwgKCnLdt27dOmRkZOB///sfALlAVx7/2WefxaxZs1zHnjt3DjExMfX+HEREzcHClIgI54uzJ554AgCwc+dOOBwOvP76665rLpVhfIVer6+15mj//v1ht9tRUFCAYcOGNfj8/fv3x759+2q1f/HFF5g0aRIWL16Mm2++udb5Bw4ciLVr1+LWW28FIF+HunbtWjz66KOu48xmM1JTU2EwGLBs2bJaPbNff/01KioqXF9v374dkyZNwsaNG9GxY0dXe1ZWFiorK9G/f/8G/1xERI3BwpSILjtWqxV5eXmw2+3Iz8/HypUr8eqrr2Ls2LG47777AACdOnVCdXU13nrrLYwbNw6bN2/Gu+++6/Y47dq1Q1lZGdauXYu+ffvCZDKhS5cuuPvuu3Hffffh9ddfR//+/XHmzBmsXbsWffr0qVVcKlJTU/HJJ5+4tS1atAgTJ07E/PnzceWVV7quGw0ODkZERAQAYNq0aZg4cSIGDRqEwYMHY968eSgvL8ef/vQnAHJROmrUKFgsFnz22Wcwm80wm80AgJiYGGi1WrfiE5CvQwWA7t27u63TunHjRnTo0KHW8UREHuPrZQGIiLxp4sSJruWddDqdiImJETfeeKP48MMPhd1udzt27ty5IiEhQQQHB4vU1FSxcOHCWssoTZ48WbRu3dptuaiqqirxj3/8Q7Rr104EBQWJhIQE8bvf/U6kp6fXm6uwsFAYjUZx4MABV9vw4cNrLUkFQEycONHte9966y3Rpk0bodfrxeDBg8XWrVtd99W1rJXy59ixY3VmUb7nwuWiRo0addFlqIiImksSwnkxERER+dTf/vY3mM1m/Oc///F1lFr27t2L66+/HocOHXL11hIReRqXiyIi8hPPPvss2rZt2+itUb0hNzcXCxcuZFFKRKpijykRERER+QX2mBIRERGRX2BhSkRERER+gYUpEREREfkFFqZERERE5BdYmBIRERGRX2BhSkRERER+gYUpEREREfkFFqZERERE5BdYmBIRERGRX/h/+h7tnWdnv1oAAAAASUVORK5CYII=\n"},"metadata":{}}],"source":["def todo(self):\n","  # List of primary issues\n","  # todo    description                                   hours   progress      Note\n","  #\n","  # todo0   A01.csv skate, long, downhill, juggling,      83      Completed\n","  #         running mean duration by category.\n","  #\n","  # todo1   A01.csv category by day of the week or        .25     DNF           Hours are spread throughout the day.\n","  #         time of day i.e. morning, afternoon, night\n","  #         or blocks of 3.\n","  #\n","  # todo2   A01.csv nltk the 'Explanation' and 'Notes'                          Word frequency might be useful to find specific muscles.\n","  #         sections? Manual descriptions are already                           Topic analysis is included in 'Activity'. Sentiment analysis is\n","  #         included in the write-up.                                           redundant since 'Notes' is informational and not opinion.\n","  #\n","  # todo3   Another tutorial chapter on merge sort.               TODO\n","  #         Compare with Python's built-in len(),\n","  #         sort(), and replace().\n","  #\n","  # todo4   The graphing part could be included in        .25     DNF           This is a good project to learn syntax and documentation since it's visual.\n","  #         Chapter 1 with pandas and SciPy.\n","  #\n","  # todo5   A01.csv longboard and running distance.       .5      DNF           Running occured around 5 times and longboarding was recorded with time.\n","  #\n","  #\n","  # todo6   P0P1B0B1.csv timeseries graphing.             45.5    Completed\n","  #\n","  # todo7   P1.csv manual vs observed prediction          46.5    Completed\n","  #         accuracy F1.\n","  #\n","  # todo8   B01.csv Pearson-Correlation and day-          2       Completed     Found that there was not correlation between parametric variables.\n","  #         delayed between calories, alcohol, exercise.                        An index similar to ENSO is redundant since there were no consecutive\n","  #                                                                             observations over 4 alcohol or excessive (calorie - calorie burned).\n","  #\n","  # todo9   A01P01B01 moving window spearman              .5      DNF           Would have to sort these for rank, which was completed in todo0.\n","  #         correlation between activity, duration,                             Square the difference between each numbers rank and sum all the numbers,\n","  #         time of day, pain, nutrients,                                       multiply by 6, divide by (number times (number squared minus one).\n","  #         calories, alcohol.                                                  1 - calculated number.\n","  #\n","  # todo10  tbd data filling and automatic predictions.   0       DNF\n","  #         idk if thats another chapter or avoided.\n","  #\n","  # todo11  Manual weather observations and PRISM data    0       DNF\n","  #         will be in a different GitHub to avoid\n","  #         confusion.\n","  #\n","  # Time spent at a computer programming\n","  # Total estimate  :\n","  # Total actual    :\n","  #\n","  # Purpose\n","  # The goal of writing this is to waste as much time as possible in between\n","  # exercise to avoid overtraining while retaining logical thought process\n","  # during long stretches of unemployment. These were written on a computer\n","  # with a 1.5-2 hour battery to restrict excessive\n","  # programming by limiting hardware access.\n","  #\n","  # Abstract\n","  # Python with C-like syntax is used for data manipulation and\n","  # graphing arrays are handled without dictionaries. The only\n","  # library used is Matplotlib for RGB graphing and to avoid writing a image or\n","  # video format that would likely spread misinformation. An implementation of\n","  # the merge sort algorithm was used to alphabetize exercise activity for\n","  # binning and graphing frequency by unique type. The built-in Python methods\n","  # for 'replace', 'split', 'len', and 'sort' were manually written for\n","  # learning purposes.\n","\n","  # Start date: 20250125\n","  # End date:\n","\n","  # Below is an exhaustive list of secondary issues.\n","\n","  # List of secondary issues\n","  # todo   description                                                  progress\n","  # todo0  rewrite parser for unicode csv str/int.\n","  # todo1  Stats class avoid NA, NAAN, -9999, etc.\n","  # todo2  refractor RGB_graphs.\n","  # todo3  monthly means on bar graphs.\n","  # todo4  organize merge_sort into another classe.                     Complete\n","  # todo5  modify merge sort to accept entire CSV.                      Class\n","  # todo6  Handle multi word activity descriptions consistently.        Class\n","  # todo7  switch the second capital letter to lower case if exists.    Class\n","  # todo8  unchain the four merge sort functions.                       Class\n","\n","  return\n","\n","# import sys\n","# for path in sys.path:\n","#   print(path)\n","import matplotlib\n","import matplotlib.pyplot as plt\n","import exercise_module as eu\n","# eu.test_function()\n","# print(sys.version)\n","# 3.10.12 (main, Mar 22 2024, 16:50:05) [GCC 11.4.0]\n","# 3.11.11 (main, Dec  4 2024, 08:55:07) [GCC 11.4.0]\n","# 3.11.13 (main, Jun  4 2025, 08:57:29) [GCC 11.4.0]\n","\n","# In development.\n","###############################################\n","# Part D: Data visualization with a RGB graph #\n","###############################################\n","# Matplotlib for color because otherwise you would have\n","# to write hardware code to avoid using Python or C libraries.\n","class Graphs_rgb: # 'Graphs_rgb_dev()' in 'exercise_module.py'\n","  # Initialize the input variables\n","  def __init__(self, data):\n","    self.data = data\n","\n","  # A1.csv calories out per activity.\n","  # TODO PLACE AT BOTTOM\n","  def rgb_timeseries_calories_out(self,data):\n","    # Sum calories for every day.\n","    data[5].append('0')\n","    data[4].append(0)\n","    day_sum = 0\n","    day = data[5][0]\n","    x1 = [day]\n","    y1 = []\n","    for i in range(len(data[4])):\n","      day_sum = day_sum + data[4][i]\n","      if data[5][i] != '':\n","        if data[5][i] == '722':\n","          continue\n","        x1.append(day)\n","        y1.append(day_sum)\n","        day = data[5][i]\n","        day_sum = 0\n","\n","    x = []\n","    y = []\n","    y2 = []\n","    y3 = []\n","    y4 = []\n","    y5 = []\n","    count = 0\n","    splicer = 5\n","    for j in range(1, len(y1), splicer):\n","      y1_slice = y1[j:j+splicer]\n","      y2_slice = [int(item) for item in data[6][j:j+splicer]]\n","      y4_slice = [int(item) for item in data[7][j:j+splicer]]\n","      y5_slice = [int(item) for item in data[8][j:j+splicer]]\n","      y.append(sum(y1_slice)/5)\n","      y2.append(sum(y2_slice)/5)\n","      y3.append((sum(y2_slice)/5)-(sum(y1_slice)/5)-2200)\n","      y4.append(sum(y4_slice)/5)\n","      y5.append(sum(y5_slice)/5)\n","      x.append(x1[j])\n","      # print(sum(y1_slice)/5,x1[j],sum(y2_slice)/5,sum(y3_slice)/5,sum(y4_slice)/5)\n","\n","    plt.figure(figsize=(11, 5), dpi=400)\n","    plt.scatter(x, y2, label='Eaten', marker='o', s=100)\n","    plt.plot(x, y2)\n","    plt.scatter(x, y3, label='Difference', marker='o', s=100)\n","    plt.plot(x, y3)\n","    plt.scatter(x, y, label='Used', marker='o', s=100)\n","    plt.plot(x, y)\n","\n","    # plt.scatter(x, y4, label='Observation', marker='o')\n","    # plt.scatter(x, y5, label='Observation', marker='o')\n","    x_pos = [i for i in x[::2]]\n","    x_label = ['7/22','8/01','8/11','8/25','9/05','9/15','9/25','10/05','10/15','10/25']\n","    x_label\n","    plt.xticks(x_pos, labels=x_label, fontsize=17)\n","    # The 'y' string removes '0' otherwise it runs into the xaxis.\n","    '''\n","    y_label = [0,1,2,3,4,5]\n","    y_label_str = [str(y) for y in y_label]\n","    y_label_str[0] = ' '\n","    plt.yticks(y_label, labels=y_label_str, fontsize=17)\n","    '''\n","    plt.ylabel('Kilocalories', fontsize=19)\n","    plt.title('Calorie Expenditure', fontsize=19)\n","    # plt.legend(loc='center left',bbox_to_anchor=(1, 0.5),fontsize=17,borderaxespad=1.2)\n","    plt.grid()\n","\n","  # Mean of all days using the daily mean by 3,5,7,...etc. before pain.\n","  def rgb_reverse_category(self,pain,not_pain,all_data):\n","\n","    x = [i[1] for i in pain]\n","    y1 = [j[0] for j in pain]\n","    y1n = [j[2] for j in pain]\n","\n","    y2 = [k[0] for k in not_pain]\n","    y2n = [k[2] for k in not_pain]\n","\n","    y3 = [l[0] for l in all_data]\n","    y3n = [l[2] for l in all_data]\n","\n","    plt.figure(figsize=(8, 6))\n","    plt.scatter(x, y1, label='Pain', marker='+')\n","    plt.scatter(x, y2, label='Not Pain', marker='_')\n","    plt.scatter(x, y3, label='All Data', marker='.')\n","    plt.xlabel('Days in Reverse', fontsize=10)\n","    plt.ylabel('Mean Daily Activities', fontsize=10)\n","    plt.title('Activites Before Pain',fontsize=12)\n","    for iter, mean in enumerate(y1):\n","      if mean > 6.5:\n","        bx_pos = x[iter] - 1.5\n","        by_pos = mean - .1\n","      else:\n","        bx_pos = x[iter] + 1.5\n","        by_pos = mean + .1\n","      box_str = 'N. ' + str(y1n[iter])\n","      plt.text(\n","          bx_pos,\n","          by_pos,\n","          box_str,\n","          ha=\"center\",\n","          va=\"bottom\",\n","          size=8,\n","          bbox=dict(facecolor=\"white\", edgecolor=\"black\", boxstyle=\"round\", alpha=0.75),\n","      )\n","    plt.xticks(x)\n","    plt.ylim(5.1,6.75)\n","    plt.grid()\n","    plt.margins(y=0.01)\n","    plt.legend(loc='upper center')\n","    plt.show()\n","\n","    # plt.savefig('P1-0 Activity Frequency Mean July-October, 2024' + '.jpg')\n","    return\n","\n","  # Prediction vs observation and accuracy, precision, F1 score.\n","  # Input is prediction, observation, date, classification scores.\n","  def rgb_prediction_observation(self,prediction,observation,date,classification_list):\n","    print(observation)\n","    x = []\n","    y1 = []\n","    y2 = []\n","    y3 = []\n","    # Filter 'NA'. Similar to 'rgb_date_time()' but the function is used in\n","    # a loop instead of the entire list of columns and doesn't average every 5 days.\n","    for j in range(1,len(prediction)):\n","      if len(date[j]) == 3:\n","        month = date[j][0:1]\n","        day = date[j][1:]\n","      else:\n","        month = date[j][0:2]\n","        day = date[j][2:]\n","      split_date = month + '/' + day\n","      if prediction[j] == 'NA' or observation[j] == 'NA':\n","        y1.append(None)\n","        y2.append(None)\n","        y3.append(None)\n","        x.append(split_date)\n","      else:\n","        if prediction[j] == observation[j]:\n","          #print(prediction[j],observation[j],date[j])\n","          y1.append(int(prediction[j]))\n","          y2.append(None)\n","          y3.append(None)\n","          x.append(split_date)\n","        else : # prediction[j] != observation[j]\n","          y1.append(None)\n","          y2.append(int(prediction[j]))\n","          y3.append(int(observation[j]))\n","          x.append(split_date)\n","\n","    # Plots the three datasets on the same graph.\n","    plt.figure(figsize=(11, 5), dpi=400)\n","    plt.scatter(x, y1, label='Same', marker='.')\n","    plt.scatter(x, y2, label='Prediction', marker='o', s=100)\n","    plt.scatter(x, y3, label='Observation', marker='o')\n","    # The 'y' string removes '0' otherwise it runs into the xaxis.\n","    x_label = [i for i in x[::10]]\n","    y_label = [0,1,2,3,4,5]\n","    y_label_str = [str(y) for y in y_label]\n","    y_label_str[0] = ' '\n","    plt.xticks(x_label, labels=x_label, fontsize=17)\n","    plt.yticks(y_label, labels=y_label_str, fontsize=17)\n","    # Stamina text box and legend is positioned different since stamina was\n","    # normally high. 'bx_pos' is used for both.\n","    bx_pos = 77.5 # x[-5]\n","    if prediction[0] == 'Stm':\n","      by_pos = 1.91\n","      plt.ylabel('Stamina', fontsize=19)\n","      plt.legend(loc='lower left',fontsize=17,borderaxespad=1.2)\n","    else:\n","      by_pos = 4.5\n","      plt.ylabel('Pain', fontsize=19)\n","      plt.title(classification_list[0], fontsize=19)\n","      plt.legend(loc='upper center',fontsize=17,borderaxespad=1.2) # upper left except columns 8-11.\n","\n","    # Includes a manual prediction and accuracy scores within a text box.\n","    box_label = ['','','Accuracy: ', 'Precision: ', 'Recall: ', 'F1 Score: ']\n","    box_str = ''\n","    for k in range(2,len(classification_list)):\n","      box_subset_str = box_label[k] + str(round(classification_list[k],2))\n","      if k < len(classification_list) - 1:\n","        box_str += box_subset_str + '\\n'\n","      else:\n","        box_str += box_subset_str\n","    plt.text(\n","        bx_pos,\n","        by_pos,\n","        box_str,\n","        ha=\"left\",\n","        va=\"top\",\n","        size=17,\n","        bbox=dict(facecolor=\"white\", edgecolor=\"#d5d8de\", boxstyle=\"round,pad=0.5\", alpha=0.8))\n","    plt.grid()\n","    #plt.margins(y=0.1)\n","    return\n","\n","  # All the erroneous pain dates with each daily mean for 3,5,7..etc.\n","  def rgb_reverse_day_mean(self,input_data,P1_data):\n","    # x = [i[1] for i in input_data] # Day_ID\n","    # Return the date\n","    # Sort the 'input_data' chronologically and include the date.\n","    input_date = []\n","    input_data_id = sorted(input_data, key=lambda y:y[1])\n","    for j in range(len(input_data_id)):\n","      splice = input_data_id[j][1] + 1\n","      input_data_j = input_data_id[j]\n","      input_data_j.append(P1_data[1][splice])\n","      input_date.append(input_data_j)\n","    # Sorting 'input_date' based on the second value or the number of days in reverse.\n","    input_date_reverse = sorted(input_date, key=lambda x: x[2])\n","    y1 = []\n","    x1 = []\n","    reverse_days = [3,5,7,10,30]\n","    # 'y1' is a list of lists with the average activies per day as sorted by 'reverse_days'.\n","    for i in range(len(reverse_days)):\n","      y_input_day = []\n","      x_input_day = []\n","      for ii in range(len(input_date_reverse)):\n","        if input_date_reverse[ii][2] == reverse_days[i]:\n","          y_input_day.append(input_date_reverse[ii][4]) # input_date_reverse[ii]\n","          date = input_date_reverse[ii][5]\n","          if len(date) == 3:\n","            month = date[0:1]\n","            day = date[1:]\n","          else:\n","            month = date[0:2]\n","            day = date[2:]\n","          if day[0] == '0':\n","            day = day[1]\n","          split_date = input_date_reverse[ii][0] + '\\n' + month + '/' + day\n","          x_input_day.append(split_date)\n","      y1.append(y_input_day)\n","      x1.append(x_input_day)\n","\n","    plt.figure(figsize=(8,6))\n","    # y = [j[4] for j in input_data]\n","    # plt.scatter(x, y) # scatterplot version without sorting.\n","\n","    # 20250616-... Google Drive takes forever to update changes\n","    # to the spreadsheet, these are hardcoded.\n","    y1[1][7] = 4    # 20 /  5 instead of 21 / 5  = 4.2\n","    y1[2][5] = 4    # 28 /  7 instaed of 29 / 7  = 4.14\n","    y1[3][4] = 4.1  # 41 / 10 instead of 42 / 10 = 4.2\n","    y1[4][2] = 5.6  # 168/ 30 instead of 169/ 30 = 5.63\n","\n","    for sub in range(len(y1)):\n","      if reverse_days[sub] < 6:\n","        plt.plot(x1[sub],y1[sub])\n","      plt.scatter(x1[sub],y1[sub],label=reverse_days[sub])\n","    # plt.ylim(0,8.5)\n","    plt.text(\n","        6,\n","        4,\n","        '',\n","        ha=\"center\",\n","        va=\"bottom\",\n","        size=8,\n","        bbox=dict(facecolor=\"white\", edgecolor=\"black\", boxstyle=\"round\", alpha=0.75),\n","    )\n","\n","    plt.legend(title='Days Before\\n      Pain',title_fontsize=10,alignment='left',loc='upper left',fontsize=8,borderaxespad=1.2)\n","    plt.xlabel('Date (2024)', fontsize=10)\n","    plt.ylabel('Average per Day', fontsize=10)\n","    plt.title('Activities Before Pain')\n","    plt.grid()\n","    plt.margins(y=0.01)\n","    return\n","\n","  # Four utility functions daisy chained to rgb_timeseries_bar()\n","  # Minor todo: unchain them lol\n","  def rgb_timeseries_mean_p01(self,formatted_data_group):\n","    # Input is list (1-4) of lists (95) of each columns values without NA\n","    # i.e. [[dist1],[dist1],[dist1], etc]\n","    date_col_len = len(formatted_data_group[0])\n","    group_mean = []\n","    # Length of the column (95 without \"NA\" as filtered in rgb_date_time)\n","    for i in range(date_col_len):\n","      row_list = []\n","      # Length of columns to be summarized (1-4) 95 row_list values\n","      for j in range(len(formatted_data_group)):\n","        row_list.append(formatted_data_group[j][i])\n","      # Mean at each day for each group\n","      row_count = len(row_list)\n","      row_sum = sum(row_list)\n","      row_mean = row_sum / row_count\n","      group_mean.append(row_mean)\n","    return group_mean\n","\n","  def rgb_date_time(self,csv_groups,date_col):\n","    day_count = len(self.data[1])\n","    k = 0\n","    # Checks the n day average list.\n","    checker_list = []\n","    checker = []\n","    group_dist = []\n","    for i in csv_groups:\n","      dist0 = []\n","      dist1 = []\n","      dist2 = []\n","      dist1_sum = 0\n","      dist1_count = 0\n","      for j in range(day_count):\n","        if j == (day_count-1):\n","          break\n","        if i[j+1] == \"NA\":\n","          continue\n","        else:\n","          # Formatting the date, subtracts 'dist1_count' to format xaxis ticks.\n","          # year = 2024\n","          date_length = date_col[j+1-dist1_count]\n","          if len(date_length) < 4:\n","            month = date_length[:1]\n","            day = date_length[1:]\n","          else:\n","            month = date_length[:2]\n","            day = date_length[2:]\n","          date_format0 = month + \"/\" + day\n","          checker.append(int(i[j+1]))\n","          dist1_sum += float(i[j+1])\n","          dist1_count += 1\n","          date_format1 = month + \"/\" + day\n","          # Mean of every n days, change the n for desired values.\n","          if dist1_count == 5:\n","            dist1_average = round((dist1_sum / dist1_count))\n","            dist1.append(int(dist1_average))\n","            checker_list.append(checker)\n","            dist0.append(date_format0)\n","            dist2.append(date_format1)\n","            dist1_count = 0\n","            dist1_sum = 0\n","            checker = []\n","      group_dist.append([dist0,dist1,dist2])\n","      k += 1\n","    return group_dist\n","\n","  def rgb_P1_style(self,final_title,line):\n","    plt.yticks(range(1,6),fontsize=17)\n","    if final_title == 'Stamina':\n","      plt.ylabel(final_title + ' 5 Day Mean',fontsize=19)\n","    else:\n","      plt.title(final_title,fontsize=19)\n","      plt.ylabel(\"Pain\",fontsize=19)\n","      if line == 1:\n","        plt.legend(title='5 Day Mean', title_fontsize=19, fontsize=17)\n","    return\n","\n","  def rgb_B1_style(self,final_title,line):\n","    if final_title == 'Calories':\n","      plt.yticks(range(2000,3400,400),fontsize=17) # 1200,4500 for B1.csv\n","      plt.ylabel(\"Intake\",fontsize=19)\n","      plt.title(final_title,fontsize=19)\n","    elif final_title == 'Alcohol Servings':\n","      plt.yticks(range(0,6),fontsize=17) # 16 for P1.csv\n","      plt.title(\"Alcohol\",fontsize=19)\n","      plt.ylabel(\"Servings\",fontsize=19)\n","    elif final_title == 'Exercise':\n","      plt.yticks(range(0,3),fontsize=17)\n","      plt.title(final_title,fontsize=19)\n","      plt.ylabel(\"Calories Out\",fontsize=19)\n","      # plt.text(.1,.5, \"Calories Out \\n2 = 250+ \\n1 = 1-249\",\n","      #   bbox={'facecolor': 'white', 'alpha': .75, 'pad': 10})\n","    else:\n","      plt.yticks(range(1,6))\n","      if line == 1:\n","        plt.title(\"Nutrients\",fontsize=19)\n","      else:\n","        plt.title(final_title,fontsize-19)\n","      plt.ylabel(\"Intake\",fontsize=19)\n","      plt.yticks(fontsize=17)\n","      plt.legend(fontsize=17)\n","    return\n","\n","  # Bar plots for each column\n","  def rgb_timeseries_bar(self,title_full,start_val,P1_B1):\n","    for i in range(start_val,len(title_full)+start_val):\n","      formatted_csv_group = self.rgb_date_time([self.data[i]],self.data[1])\n","      fig, ax = plt.subplots(1, 1, layout='constrained', figsize=(11, 5), dpi=400)\n","      ax.bar(formatted_csv_group[0][0], formatted_csv_group[0][1], width=0.8, align='edge', label='5 Day Mean')\n","      final_title = title_full[i-start_val]\n","      # Format the title, yticks, and ylabel\n","      if P1_B1 == 0:\n","        self.rgb_P1_style(final_title,0)\n","      elif P1_B1 == 1:\n","        self.rgb_B1_style(final_title,0)\n","      elif P1_B1 == 2:\n","        pass\n","        # self.rgb_A0_style(final_title,0)\n","      tick_positions = formatted_csv_group[0][2][::4]  # Get every n position\n","      plt.xticks(tick_positions, labels=tick_positions,\n","                 fontsize=17)\n","      plt.margins()\n","      # plt.legend(fontsize=17) # P1 specifies 5 day mean\n","      plt.grid()\n","      # break\n","      # plt.savefig(final_title + '.jpg')\n","    return\n","\n","  # Returns a date list without blanks\n","  def rgb_date_list(self):\n","    # date_literal is 0-30 days\n","    date_literal = []\n","    # Makes a list with only the dates\n","    for i in range(1,len(self.data[2])):\n","      if len(self.data[2][i]) > 0:\n","        date_literal.append(self.data[2][i])\n","    return date_literal\n","\n","  # Multiple lines same graphs.\n","  def rgb_timeseries_line(self,title_full,start_val,groups_num,title_label,P1_B1):\n","    data = self.data\n","    # secondary todo: name instead of number position\n","    j = 1\n","    # Adding multiple lines to a single plot by group with formatting\n","    for i in range(len(groups_num)):\n","      subset0 = groups_num[i:j][0]\n","      if subset0 == groups_num[-1]:\n","        break\n","      subset1 = groups_num[i+1:j+1][0]\n","      csv_groups = data[subset0:subset1]\n","      formatted_csv_group = self.rgb_date_time(csv_groups,self.data[1])\n","      # Format subplot\n","      fig, ax = plt.subplots(1, 1, layout='constrained', figsize=(11, 5), dpi=400)\n","      # Get the formatted_csv_group second list of values in each group\n","      dist1_list = [dist1[1] for dist1 in formatted_csv_group]\n","      # First 3 columns in data are ID, while the title list isn't.\n","      # Subtract each subset by the start_val of the values (excluding date, id, etc)\n","      title_group = title_full[(subset0-start_val):(subset1-start_val)]\n","      # y = each dist1 in formatted_csv_group, x = every date value, x labels = every 5th date value\n","      for k in range(len(dist1_list)):\n","        ax.plot(formatted_csv_group[0][0], dist1_list[k], label=title_group[k], linewidth=4)\n","        # Format the title, yticks, and ylabel\n","        if P1_B1 == 0:\n","          self.rgb_P1_style(title_label[j-1],1)\n","        elif P1_B1 == 1:\n","          self.rgb_B1_style(title_label[j-1],1)\n","      # Chart formatting and save\n","      tick_positions = formatted_csv_group[0][2][::2]  # Get every n position\n","      plt.xticks(tick_positions, labels=tick_positions,\n","                 fontsize=17)\n","      plt.grid()\n","      plt.margins()\n","      #plt.savefig(title_label[j-1] + '.jpg')\n","      j += 1\n","    return\n","\n","  # Summarized with mean\n","  def rgb_timeseries_small(self,csv_groups_num,legend_label,ax):\n","    csv = self.data\n","    j = 1\n","    for i in range(len(csv_groups_num)):\n","      subset0 = csv_groups_num[i:j][0]\n","      if subset0 == csv_groups_num[-1]:\n","        break\n","      subset1 = csv_groups_num[i+1:j+1][0]\n","      csv_groups = csv[subset0:subset1]\n","      # Builds an array to skip NA and format the date\n","      # [[[dist0],[1],[2]],[[dist0],[1],[2]], etc]]]\n","      formatted_csv_group = self.rgb_date_time(csv_groups,self.data[1])\n","      # Get the formatted_csv_group second list of values in each group\n","      dist1_list = [dist1[1] for dist1 in formatted_csv_group]\n","      # Summarize each body part's group with mean\n","      dist1_group_mean = self.rgb_timeseries_mean_p01(dist1_list)\n","      # y = group mean, x = every date value, x labels = every 5th date value\n","      # Specified in rgb_date_time function\n","      ax.plot(formatted_csv_group[0][0], dist1_group_mean, label=legend_label[j-1], linewidth=4)\n","      # Chart formatting\n","      tick_positions = formatted_csv_group[0][2][::2]  # Get every n position\n","      plt.xticks(tick_positions, labels=tick_positions,\n","                  fontsize=17)\n","      j += 1\n","    return\n","\n","  # A01.csv frequency of merged 'Activity'.\n","  def rgb_timeseries_frequency(self,data):\n","    y = data[0][-11:]\n","    x = data[1][-11:]\n","    fig, ax = plt.subplots(figsize=(15, 17),dpi=400)\n","    bars = ax.barh(x,y,height=.5)\n","    for i in range(len(y)):\n","      plt.text(y[i]-2.5, x[i], str(y[i]), color='White', fontsize=17, ha='center', va='center', bbox={'facecolor': 'none','linewidth': 0})\n","    plt.title('Activity Frequency\\nJuly-October, 2024', pad=50, fontsize=19)\n","    # plt.title('Activity Frequency May, 2024', pad=50, fontsize=19)\n","    ax.tick_params(axis='both', labelsize=17)\n","    ax.tick_params(axis='y', pad=50)\n","    ax.xaxis.set_ticks_position('top')\n","    plt.yticks(x, labels=x, ha='center', fontsize=17)\n","    plt.grid(axis='x')\n","    plt.margins(y=0.01)\n","    # plt.savefig('A1-0 Activity Frequency July-October, 2024' + '.jpg')\n","    return\n","\n","  # A01.csv duration of merged 'Activity' hours.\n","  def rgb_timeseries_duration(self,data):\n","    y = [round(j) for j in data[0][-11:]]\n","    x = data[1][-11:]\n","    # x[5] = 'Guitar,\\nRest' # A0.csv\n","    fig, ax = plt.subplots(figsize=(15, 17),dpi=400)\n","    bars = ax.barh(x,y,height=.5)\n","    for i in range(len(y)):\n","      plt.text(y[i]-3, x[i], str(y[i]), color='White', fontsize=17, ha='center', va='center', bbox={'facecolor': 'C0','linewidth': 0})\n","    plt.title('Activity Duration\\nJuly-October, 2024', pad=50, fontsize=20)\n","    # plt.title('Activity Duration May, 2024', pad=50, fontsize=19)\n","    plt.xlabel('Hours', fontsize=17)\n","    ax.tick_params(axis='y', pad=50, labelsize=17)\n","    ax.tick_params(axis='x', labelsize=17)\n","    ax.xaxis.set_ticks_position('top')\n","    ax.xaxis.set_label_position('top')\n","    plt.yticks(x, labels=x, ha='center', fontsize=17)\n","    plt.grid(axis='x')\n","    plt.margins(y=0.01)\n","    # plt.savefig('A1-0 Activity Duration July-October, 2024' + '.jpg')\n","    return\n","\n","  # A01.csv mean of merged 'Activity' frequency / (sum of minutes)\n","  def rgb_timeseries_mean(self,data):\n","    y = [round(j,2) for j in data[0][-11:]]\n","    x = data[1][-11:]\n","    y.pop(0)\n","    x.pop(0)\n","    fig, ax = plt.subplots(figsize=(15, 17),dpi=400)\n","    bars = ax.barh(x,y,height=.5)\n","    for i in range(len(y)):\n","      plt.text(y[i]-.25, x[i], str(y[i]), color='White', fontsize=17, ha='center', va='center', bbox={'facecolor': 'C0','linewidth': 0})\n","    plt.title('Total Activity Average\\nJuly-October, 2024', pad=50, fontsize=20)\n","    plt.xlabel('Hours', fontsize=17)\n","    ax.tick_params(axis='y', pad=50, labelsize=17)\n","    ax.tick_params(axis='x', labelsize=17)\n","    ax.xaxis.set_ticks_position('top')\n","    ax.xaxis.set_label_position('top')\n","    plt.yticks(x, labels=x, ha='center', fontsize=17)\n","    plt.grid(axis='x')\n","    plt.margins(y=0.01)\n","    # plt.savefig('A1-0 Total Activity Average July-October, 2024' + '.jpg')\n","\n","  # A01.csv daily mean.\n","  def rgb_timeseries_daily_mean(self,data):\n","    y = [round(j) for j in data[0][-11:]]\n","    x = data[1][-11:]\n","    y.pop(0) # 'write'\n","    x.pop(0) # 'write'\n","    fig, ax = plt.subplots(figsize=(15, 17),dpi=400)\n","    bars = ax.barh(x,y,height=.5)\n","    for i in range(len(y)):\n","      plt.text(y[i]-1.5, x[i], str(y[i]), color='White', fontsize=17, ha='center', va='center', bbox={'facecolor': 'C0','linewidth': 0})\n","    plt.title('Daily Activity Average\\nJuly-October, 2024', pad=50, fontsize=20)\n","    plt.xlabel('Minutes', fontsize=17)\n","    ax.tick_params(axis='y', pad=50, labelsize=17)\n","    ax.tick_params(axis='x', labelsize=17)\n","    ax.xaxis.set_ticks_position('top')\n","    ax.xaxis.set_label_position('top')\n","    plt.yticks(x, labels=x, ha='center', fontsize=17)\n","    plt.grid(axis='x')\n","    plt.margins(y=0.01)\n","    # plt.savefig('A1-0 Daily Activity Average July-October, 2024' + '.jpg')\n","\n","#################################################\n","# Part E: Part D visualization helper functions #\n","#################################################\n","# Merge sort is the fastest for worst case scenario sorting: N log(n)\n","# Implementation is from W3 and modified for AZ with ascii ord():\n","# https://www.w3schools.com/dsa/dsa_algo_mergesort.php\n","# Bubble sort is the fastest for almost sorted lists O(n)\n","# https://www.w3schools.com/dsa/dsa_timecomplexity_bblsort.php\n","# Python's built-in sort() function uses Tim Sort which uses a hybrid\n","# Insertion and Merge. Insertion is similar to Bubble with the same\n","# Time and Space complexity with worst case O(n^2) and best O(n).\n","class Graphs_sort:\n","  # Initialize the input variables\n","  def __init__(self, data):\n","    self.data = data\n","\n","  # Filters the verb endings using c_replace().\n","  def filter_stop(self,column):\n","    filtered_column = []\n","    for i in column:\n","      if 'Walked' in i:\n","        filtered_column.append(\"Walk\")\n","      elif 'Juggling' in i:\n","        filtered_column.append(\"Juggle\")\n","      elif 'Driving' in i:\n","        filtered_column.append(\"Drive\")\n","\n","      # english hard idk\n","      elif 'Reading' in i:\n","        filtered_column.append(\"Read\")\n","      elif 'Writing' in i:\n","        filtered_column.append(\"Write\")\n","      elif 'No juggling' in i:\n","        filtered_column.append(\"No juggling\")\n","      elif 'Running' in i:\n","        filtered_column.append(\"Run\")\n","      elif 'Hiking' in i:\n","        filtered_column.append(\"Hike\")\n","      elif 'Rested' in i:\n","        filtered_column.append(\"Rest\")\n","      elif 'Stretched' in i:\n","        filtered_column.append(\"Stretch\")\n","\n","      elif i == 'Lifts':\n","        # Could append since this is hard coded but I wanted to test.\n","        verb_less = i.replace(\"s\", \"\")\n","        # verb_less = self.c_replace(i, \"s\", \"\")\n","        filtered_column.append(verb_less)\n","      elif 'ing' in i:\n","        verb_less = i.replace(\"ing\", \"\")\n","        # verb_less = self.c_replace(i, \"ing\", \"\")\n","        filtered_column.append(verb_less)\n","      else:\n","        filtered_column.append(i)\n","    return filtered_column\n","\n","  # Calculates duration using end - start.\n","  def sort_time(self,activity,start,end):\n","    duration = ['Duration']\n","    for i in range(1,len(start)):\n","      # Checks to see if the Activity or Start column is empty.\n","      # if len(activity[i]) == 0 or len(start[i]) == 0:\n","      #  continue\n","      # Estimates sleep at 7 hours.\n","      dur = 0\n","      if 'Sleep' == activity[i]:\n","        dur = str(7*60)\n","      else:\n","        # Converts the '100' digits to '60' minutes in hours.\n","        # Gets the end hour.\n","        if len(end[i]) == 4:      # handles 1030 4 digits\n","          end_sub = end[i][:2]\n","        elif len(end[i]) == 3:    # handles 0930 3 digits\n","          end_sub = end[i][0]\n","        else:                     # handles 0030 2 digits\n","          end_sub = 0\n","        # Gets the start hour.\n","        if len(start[i]) == 4:    # handles 1030 4 digits\n","          start_sub = start[i][:2]\n","        elif len(start[i]) == 3:  # handles 0930 3 digits\n","          start_sub = start[i][0]\n","        else:                     # handles 0030 2 digits\n","          start_sub = 0\n","        # Subtracts 40 minutes since there are 60 in an hour not 100.\n","        if start_sub == end_sub:\n","          if int(end[i]) == int(start[i]):\n","            dur = str(5)\n","          else:\n","            dur = str(int(end[i]) - int(start[i]))\n","        else:\n","          # Turn over from one day to another.\n","          if int(end[i]) < int(start[i]):\n","            # First day's amount of hours (24 - the start time hour)\n","            first_day = 23 - int(start_sub)\n","            first_day_minutes = 60 - int(start[i][2:]) # the last two digits are the minutes\n","            # Second day's hours added to the first day's hours as 'dur' as minutes.\n","            if len(end[i]) == 4:\n","              second_day_minutes = end[i][2:]\n","            elif len(end[i]) == 3:\n","              second_day_minutes = end[i][1:]\n","            else: # There are no extra hours\n","              second_day_minutes = end[i]\n","            end_sub = end_sub + first_day\n","            hunid = (int(end_sub)) * 60 # hour difference converted to minutes\n","            dur = hunid + first_day_minutes + int(second_day_minutes)\n","          else:\n","            hunid = (int(end_sub) - int(start_sub)) * 40\n","            dur = str( ( int(end[i]) - int(start[i]) ) - hunid)\n","      duration.append(dur)\n","    return duration\n","\n","  # Merge sorts a list splice of strings from 'sort_ascii()' based on 'ord()'\n","  # and returns them to 'sort_ascii()'.\n","  def merge(self,left_in,right_in):\n","      result = []\n","      result_activity = []\n","      result_id = []\n","      result_dur = []\n","      i = j = 0\n","      while i < len(left_in[1]) and j < len(right_in[1]):\n","        left = left_in[0][i]\n","        right = right_in[0][j]\n","        left_activity = left_in[1][i]\n","        right_activity = right_in[1][j]\n","        left_id = left_in[2][i]\n","        right_id = right_in[2][j]\n","        left_dur = left_in[3][i]\n","        right_dur = right_in[3][j]\n","        if left < right: # or (left_activity_replace == right_activity and left < right) ?\n","          result.append(left)\n","          result_activity.append(left_activity)\n","          result_id.append(left_id)\n","          result_dur.append(left_dur)\n","          i += 1\n","        elif left > right: # or left_activity == right_activity ?\n","          result.append(right)\n","          result_activity.append(right_activity)\n","          result_id.append(right_id)\n","          result_dur.append(right_dur)\n","          j += 1\n","        else:\n","          if len(left_activity) > len(right_activity):\n","            length = len(right_activity)\n","          else: # same length?\n","            length = len(left_activity)\n","          # Find where the two words are different at k.\n","          for k in range(1,length):\n","            if left_activity[k] != right_activity[k]:\n","              break\n","          # Handles when the comparison first words are the same but\n","          # one of the comparisons have a space and second word.\n","          left_ord = ord(left_activity[k])\n","          right_ord = ord(right_activity[k])\n","          if left_activity[:length] == right_activity[:length]:\n","            if length < len(right_activity):\n","              if left_activity == right_activity[:length]:\n","                left_ord = -1\n","                # Comparison right_activity[length:] is longer and different.\n","                right_ord = ord(right_activity[length:][0])\n","          if left_activity[:k] == right_activity[:k] and left_ord < right_ord:\n","            result.append(left)\n","            result_activity.append(left_activity)\n","            result_id.append(left_id)\n","            result_dur.append(left_dur)\n","            i += 1\n","          else:\n","            result.append(right)\n","            result_activity.append(right_activity)\n","            result_id.append(right_id)\n","            result_dur.append(right_dur)\n","            j += 1\n","      result.extend(left_in[0][i:])\n","      result.extend(right_in[0][j:])\n","      result_activity.extend(left_in[1][i:])\n","      result_activity.extend(right_in[1][j:])\n","      result_id.extend(left_in[2][i:])\n","      result_id.extend(right_in[2][j:])\n","      result_dur.extend(left_in[3][i:])\n","      result_dur.extend(right_in[3][j:])\n","\n","      return [result,result_activity,result_id,result_dur]\n","\n","  # def sort_ascii(self,time_ID,ord_list,activity_filter,duration):\n","  # todo: avoid modification of the input variables with 'input[:]'\n","  def sort_ascii(self,ord_list,activity_filter,time_ID,duration):\n","    length = len(time_ID) - 1\n","    step = 1\n","    while step < length:\n","      for i in range(1, length, 2 * step):\n","        # Time vs space trade off: if you want less space calculate the duration\n","        # with another loop before sorting. Otherwise, the End and Start columns\n","        # are included in sorting and space is linear * number of columns (4).\n","        left = [ord_list[i:i + step],activity_filter[i:i + step], time_ID[i:i + step], duration[i:i + step]]\n","        right = [ord_list[i + step:i + 2 * step],\n","                 activity_filter[i + step:i + 2 * step], time_ID[i + step:i + 2 * step], duration[i + step:i + 2 * step]]\n","        merged = self.merge(left, right)\n","        # Place the merged array back into the original array\n","        for j in range(len(merged[0])):\n","          ord_list[i + j] = merged[0][j]\n","          activity_filter[i + j] = merged[1][j]\n","          time_ID[i + j] = merged[2][j]\n","          duration[i + j] = merged[3][j]\n","      step *= 2  # Double the sub-array length for the next iteration\n","    return [activity_filter,time_ID,duration]\n","\n","  # Returns the time_id and unique activity lists.\n","  def sort_unique_words(self,activity_col):\n","    # A0_length is 0-225\n","    activity_unique = []\n","    # Unique words in Activity\n","    for i in range(len(activity_col)):\n","      if activity_col[i] not in activity_unique:\n","        if len(activity_col[i]) == 0:\n","          continue\n","        else:\n","          activity_unique.append(activity_col[i])\n","    return activity_unique\n","\n","  # Returns the sorted list into AZ bins. C esque syntax.\n","  # Dimensions: 'sort_unique_words' by the number of occurances in 'sort_ascii'.\n","  def sort_unique_bin(self,sort_unique_words,sort_ascii):\n","\n","    # Once the word is different than the next word, bin the next\n","    # word (or words) since the list is already sorted.\n","\n","    # Empty 'unique_bin' is generated with int. Could use '0's but these\n","    # are 0,1,2,...n!\n","    unique_bin = [\n","        [[x],[x]] for x in range(len(sort_unique_words))\n","        ]\n","    count = 0\n","    for i in range(len(sort_ascii[0])):\n","      # Avoids checking 'sort_ascii' past the length of the list.\n","      # print(count, unique_bin[count], len(sort_unique_words))\n","      if i == (len(sort_ascii[0])-1):\n","        # If there are exactly one entry in the final 'sort_unique_words',\n","        # 'count' of type 'int' is placed as two lists into the identifier list.\n","        if unique_bin[-1][0][0].__class__ == int:\n","          unique_bin[-1] = [[sort_unique_words[count]]]\n","        break\n","      if sort_ascii[0][i] == sort_ascii[0][i+1]:\n","        # Words are the same, 'count' does not get incremented.\n","        if unique_bin[count][0][0].__class__ == str:\n","          # If first key or 'unique_bin[count]' is str, don't include it.\n","          unique_bin[count].append([sort_ascii[0][i],sort_ascii[1][i],sort_ascii[2][i]])\n","        else:\n","          unique_bin[count] = [\n","              [sort_unique_words[count]],\n","              [sort_ascii[0][i],sort_ascii[1][i],sort_ascii[2][i]]\n","              ]\n","      elif (sort_ascii[0][i-1] != sort_ascii[0][i]) and (sort_ascii[0][i] != sort_ascii[0][i+1]):\n","        # Previous word and next word are different.\n","        unique_bin[count] = [\n","            [sort_unique_words[count]],\n","            [sort_ascii[0][i],sort_ascii[1][i],sort_ascii[2][i]]\n","            ]\n","        count += 1\n","      elif (sort_ascii[0][i-1] == sort_ascii[0][i]) and (sort_ascii[0][i] != sort_ascii[0][i+1]):\n","        # Previous word is the same, next word is different.\n","        unique_bin[count].append([sort_ascii[0][i],sort_ascii[1][i],sort_ascii[2][i]])\n","        count += 1\n","      else:\n","        count += 1\n","    # Append last element of sorted list onto the bin list at end\n","    unique_bin[-1].append([sort_ascii[0][-1],\n","                           sort_ascii[1][-1],\n","                           sort_ascii[2][-1]])\n","    return unique_bin\n","\n","  # Orders 'int' or 'float' instead of strings.\n","  # secodnary todo use one list instead of several lists (also for sort_ascii())\n","  def merge_int(self, left, right):\n","    result_int = []\n","    result_activity = []\n","    i = j = 0\n","    while i < len(left[0]) and j < len(right[0]):\n","      if left[0][i] < right[0][j]:\n","        result_int.append(left[0][i])\n","        result_activity.append(left[1][i])\n","        i += 1\n","      else:\n","        result_int.append(right[0][j])\n","        result_activity.append(right[1][j])\n","        j += 1\n","    result_int.extend(left[0][i:])\n","    result_int.extend(right[0][j:])\n","    result_activity.extend(left[1][i:])\n","    result_activity.extend(right[1][j:])\n","    return [result_int, result_activity]\n","\n","  # Orders list of only 'int' or 'float'. From W3 schools.\n","  def merge_sort_int(self,int_in,activity_in):\n","    # The splice everything is used to avoid modification\n","    # of the input variables.\n","    array_int = int_in[:]\n","    activity = activity_in[:]\n","    step = 1  # Starting with sub-arrays of length 1\n","    length = len(array_int) - 1\n","    while step < length:\n","      for i in range(0, length, 2 * step):\n","        left = [array_int[i:i + step],activity[i:i + step]]\n","        right = [array_int[i + step:i + 2 * step],activity[i + step:i + 2 * step]]\n","        merged = self.merge_int(left, right)\n","        # Place the merged array back into the original array\n","        for j in range(len(merged[0])):\n","          array_int[i + j] = merged[0][j]\n","          activity[i + j] = merged[1][j]\n","      step *= 2  # Double the sub-array length for the next iteration\n","    return [array_int,activity]\n","\n","  # todo: use multiple variables\n","  # Merges entries if the first word in the string is the same. Uses C syntax.\n","  # If you're a stickler, replace 'for i in range()' with 'while iterator <= len(data)'\n","  def merge_similar_activities(self, sorted_list):\n","    # Specific formatting for this dataset.\n","    ######################################################################\n","    x = [i[0][0] for i in sorted_list[1:]] # or A0_sort_unique\n","    z = [len(k[1:]) for k in sorted_list[1:]] # frequency of each activity\n","    y = []\n","    # Calculate the hours for duration.\n","    for j in sorted_list[1:]:\n","      y_label = []\n","      for m in j[1:]:\n","        y_label.append(float(m[2]))\n","      y.append(round(sum(y_label) / 60, 4))\n","    # This is a bad method to avoid binning 'Skateboard paper' into\n","    # 'Skateboard' but I want to do the graphing.\n","    for ayy in range(len(x)):\n","      if x[ayy] == 'Skateboard paper':\n","        x[ayy] = 'paper Skateboard'\n","      if x[ayy] == 'Skateboard videos':\n","        x[ayy] = 'videos Skateboard'\n","\n","    ######################################################################\n","\n","    # Combining similar Activities. The dataset uses the same word plus\n","    # a number to denote multiple of the same activities on the same day.\n","    y_mean = round(sum(y) / float(len(y)), 4)\n","    count_0 = 0\n","    count_1 = 1\n","    root_bool = False\n","\n","    # Time complexity is the number of Activities.\n","    #for count_0 in range(len(y)):\n","    x[count_0] = x[count_0]\n","    y[count_0] = y[count_0]\n","    z[count_0] = z[count_0]\n","    spliced = []\n","    while True:\n","      if count_1 == len(y):\n","        x[count_0] = x[count_0]\n","        y[count_0] = y[count_0]\n","        z[count_0] = z[count_0]\n","        break\n","      x[count_1] = x[count_1]\n","      y[count_1] = y[count_1]\n","      z[count_1] = z[count_1]\n","      x_0 = x[count_0].split(' ') # c_split\n","      x_1 = x[count_1].split(' ') # c_split\n","      # Comparison operators to find the first instance of the word.\n","      # i.e. 'Eat' followed by 'Eat 0', 'Eat 1', etc.\n","      if x_0[0] == x_1[0]:\n","        if x_1[1] != 'outside':\n","          if ' ' not in x[count_0]:\n","            #if len(x_1) < 3:\n","            if root_bool == False:\n","              root_pos = count_0\n","              root_bool = True\n","      if root_bool == True:\n","        # Skip merging 'Skateboard paper' and 'Skateboard videos'.\n","        if y[root_pos] != y[count_0]:\n","          # 'y' value at 'count_0' is cumulative\n","          y[root_pos] += y[count_0]\n","          z[root_pos] += z[count_0]\n","        # The first 'y' value at 'root_pos' is the same as the total.\n","        x[count_0] = x[root_pos]\n","        y[count_0] = y[root_pos]\n","        z[count_0] = z[root_pos]\n","      else:\n","        x[count_0] = x[count_0]\n","        y[count_0] = y[count_0]\n","        z[count_0] = z[count_0]\n","      # This checks to see if the word and next word are different or the next\n","      # word is the same and is has three or more words, 'root_bool' is False.\n","      if x_0[0] != x_1[0] or len(x_1) >= 3:\n","        if root_bool == True:\n","          extra_numbers = (count_0+1) - (root_pos+1)\n","          # 'spliced' numbers list gets three values that slice the remaining\n","          # identical words in another loop.\n","          spliced = spliced + [[(count_0-extra_numbers),count_0, extra_numbers]]\n","          # The values at 'root_pos' get set to the current value at 'count_0'.\n","          x[count_0-extra_numbers] = x[count_0]\n","          y[count_0-extra_numbers] = y[count_0]\n","          z[count_0-extra_numbers] = z[count_0]\n","          root_bool = False\n","      count_0 += 1\n","      count_1 += 1\n","\n","    ######################################################################\n","    # Reorganizing the strings (bad method)\n","    # Also inserts '\\n' breaks if the string is longer than 10 characters\n","    # and more than one word.\n","    for bay in range(len(x)):\n","      if x[bay] == 'paper Skateboard':\n","        x[bay] = 'Skateboard paper'\n","      if x[bay] == 'videos Skateboard':\n","        x[bay] = 'Skateboard videos'\n","      string_count = 0\n","      for cay in x[bay]:\n","        if string_count > 9:\n","          string_break = x[bay].split(' ')\n","          string_word_count = len(string_break)\n","          if string_word_count > 1:\n","            string_word_mid = round(string_word_count / 2)\n","            string_0_half = \" \".join(string_break[:string_word_mid]) + '\\n'\n","            string_1_half = \" \".join(string_break[string_word_mid:])\n","            x[bay] = string_0_half + string_1_half\n","          break\n","        string_count += 1\n","    return [x,y,z,spliced]\n","\n","  # Uses 'merge_similar_activities' to splice the data.\n","  def merge_activities_splice(self,merged_activiites):\n","    # Time complexities is the number of repeated words that are being merged.\n","    x = []\n","    y = []\n","    z = []\n","    spler = []\n","    for k in range(len(merged_activiites[3])+1): # or while the length is less than the\n","      # The end splice.\n","      if k == len(merged_activiites[3]):\n","        # spler = spler + [[middle_0,0]] <- checks that the numbers are correct\n","        x = x + merged_activiites[0][middle_0:]\n","        y = y + merged_activiites[1][middle_0:]\n","        z = z + merged_activiites[2][middle_0:]\n","        break\n","      # The first splice.\n","      if x == []:\n","        # spler = [[0,merged_activiites[3][k][0]+1]]\n","        x = merged_activiites[0][0:merged_activiites[3][k][0]+1]\n","        y = merged_activiites[1][0:merged_activiites[3][k][0]+1]\n","        z = merged_activiites[2][0:merged_activiites[3][k][0]+1]\n","        # This part is carried into the next splice.\n","        middle_0 = merged_activiites[3][k][0]+1 + merged_activiites[3][k][2]\n","      else: # The middle splices.\n","        # spler = spler + [[middle_0, merged_activiites[3][k][0]+1]]\n","        x = x + merged_activiites[0][middle_0:merged_activiites[3][k][0]+1]\n","        y = y + merged_activiites[1][middle_0:merged_activiites[3][k][0]+1]\n","        z = z + merged_activiites[2][middle_0:merged_activiites[3][k][0]+1]\n","        # This part is carried into the next splice.\n","        middle_0 = merged_activiites[3][k][0]+1 + merged_activiites[3][k][2]\n","    return [x,y,z]\n","\n","  # Flips Horizontal list of lists to vertical. Similar to NumPy reshape().\n","  # Input test dimensions are seven days by eight categories.\n","  def direction_flipper(self, input):\n","    # Get some vert.\n","    count = 0\n","    count_ct = 0\n","    count_br = 0\n","    output = []\n","    activity_count = []\n","    while True:\n","      if count == len(input):\n","        # When 'count' reaches the length of the list of horizontal lists input,\n","        # append the vertical list.\n","        output.append(activity_count)\n","        # 'count' resets, 'count_ct' increases by one,\n","        # and a new nested list is declared.\n","        count = 0\n","        count_ct += 1\n","        activity_count = []\n","        if count_br == ((len(input[0])) * (len(input))):\n","          break\n","      # 'count_ct' stays the same each time and 'count' is incremented each\n","      # time to get the first value of each list.\n","      activity_count.append(input[count][count_ct])\n","      count += 1\n","      count_br += 1\n","    return output\n","\n","\n","  # Returns the abnormal pain entry.\n","  def erroneous_values(self,P1_vert_column):\n","    erroneous_values = [[P1_vert_column[0],'NA']]\n","    non_erroneous_values = [[P1_vert_column[0],'NA']]\n","    all_values = [[P1_vert_column[0],'NA']]\n","    for i in range(len(P1_vert_column)):\n","      if len(P1_vert_column[i]) > 1:\n","        continue\n","      # Append all values to calculate overall mean.\n","      all_values.append([P1_vert_column[i], i-1])\n","      # Not stamina and greater than 4 pain values and 'Day_ID' get sent\n","      # to the list of lists.\n","      if P1_vert_column[0] != 'Stm' and int(P1_vert_column[i]) > 3:\n","        erroneous_values.append([P1_vert_column[i], i-1])\n","      # If it is stamina, check for values 2 and less.\n","      elif P1_vert_column[0] == 'Stm' and int(P1_vert_column[i]) < 3:\n","        erroneous_values.append([P1_vert_column[i], i-1])\n","      else:\n","        # Otherwise it is a normal value.\n","        non_erroneous_values.append([P1_vert_column[i], i-1])\n","    return [erroneous_values,non_erroneous_values,all_values]\n","\n","  # Calculates the activity frequency for each day in ~ 500 iterations.\n","  # Returns 'Day_ID', 'start', and 'end' for splicing in 'activity_reverse()'.\n","  def activity_frequency_splice(self):\n","    # Skips the first ten values, 'Day_ID' is '10' in P1.csv and\n","    # 'start' is the 'Time_ID' in A1.tsv. The first 10 days are discarded\n","    # because they are why the information was collected.\n","    start = 53\n","    activity_frequency = []\n","    # The 'data' is from the function's class and needs a boilerplate\n","    # value appended to return the entire length of the 'data' list.\n","    data = self.data[0]\n","    data.append('100')\n","    for i in range(start,len(data)):\n","      # Checks 'Day_ID' P1.csv against 'Time_ID' from A1.tsv.\n","      # If 'Day_ID' is not '' or the values in A1.tsv,\n","      # they must by an integer (as long as the first value\n","      # header 'Day_ID' is ignored).\n","      if len(data[i]) > 0:\n","        day_id = int(data[i])\n","        activity_frequency.append([day_id-1, start, i])\n","        # 'start' is set to the 'i' or the iterator, which resumes checking\n","        # the length of A1.tsv.\n","        start = i\n","    # Deletes the null first value.\n","    del activity_frequency[0]\n","    return activity_frequency\n","\n","  # Function to find the number of activities [30,10,7,5,3] and\n","  # returns the ['Category', 'Day_ID', 'Number of Days', 'Activity Frequency', 'Frequency per Day']\n","  def activity_reverse(self,day_id,activity_frequency):\n","    counter = 0\n","    known_ID = int(day_id[2][1])\n","    activity_reverse = []\n","    for i in range(len(day_id)):\n","      if type(day_id[i][1]) == str:\n","        category = day_id[i][0] # the category\n","      elif type(day_id[i][1]) == int:\n","        if day_id[i][1] > 9:\n","          # The number of days in reverse.\n","          reverse_days = [3,5,7,10,30]\n","          # 'Day_ID' ignores the first 10 days by subtracting 10 from 'start' and 'end'.\n","          # activity_by_category = []\n","          for k in range(len(reverse_days)):\n","            # 'end' is set to the 'Day_ID' when calculating the first reverse day '3'\n","            # Otherwise, it is a subtracted 'known_ID' that is the previous 'start' value below.\n","            if reverse_days[k] == 3:\n","              end = day_id[i][1]\n","            else:\n","              end = known_ID\n","            start = day_id[i][1] - reverse_days[k]\n","            # print('start: ', start, ' = ', day_id[i][1], ' - ', reverse_days[k])\n","            # print('end: ', end)\n","            # Avoids calculating frequencies for the first 10 days.\n","            if start > 9:\n","              # The number of activities 'reverse_days[k]' from the pain observation.\n","              activity_total = 0\n","              for j in range(start-10,end-10):\n","                # Summation for the number of activities, 'reverse_days' (k) from pain observation.\n","                activity_difference = activity_frequency[j][2] - activity_frequency[j][1]\n","                # print('Activity calculating : ', activity_difference, ' = ', activity_frequency[j][2], ' - ', activity_frequency[j][1])\n","                activity_total += activity_difference\n","                counter += 1\n","              # 'known_ID' is used to avoid calculating frequencies that are already known\n","              # by using the previous start to avoid duplicated iterations.\n","              known_ID = start\n","              # If 'k' is greater than '0', the previous day range frequency difference\n","              # was already calcualted and is used to calculate the frequency, reducing\n","              # unnecessary iterations. If 'reverse_days[k]' is '5' the frequency is already\n","              # known for '3', the difference for days '4' and '5' are calculated and added\n","              # onto 'activity_previous'.\n","              if k > 0:\n","                activity_previous = activity_intermediate + activity_total\n","              else:\n","                activity_previous = activity_total\n","              # The previous total is held for the next iteration.\n","              # print('Activity Total = ', activity_previous)\n","              activity_intermediate = activity_previous\n","              # Calculate the 'Activity Frequency' and 'Days' to get the the average of each day.\n","              activity_day_mean = round(activity_previous / reverse_days[k],2)\n","              activity_reverse.append([category,day_id[i][1],reverse_days[k],activity_previous,activity_day_mean])\n","          # print(category,day_id[i][1],reverse_days[k],activity_previous)\n","          if i+1 == len(day_id):\n","            break\n","          # May or may not need this depending on the oscillatory mean of meridians along Neptune reflecting Sun farts.\n","          # known_ID = day_id[i+1][1]\n","          # Avoids when the only 'reverse_days[k]' is '30' and is the only\n","          # 'start' that's less than '9'. [3,5,7,10] have already been\n","          # calculated.\n","          #if known_ID == 'NA':\n","          #  known_ID = day_id[i+2][1]\n","          #print('known ID: ', known_ID)\n","    # print(counter) # ~472 iterations without skips or 250 with skipping already calculated differences.\n","    return activity_reverse\n","\n","  # Function to find the mean for each day group [3,5,7,10,30] mean.\n","  def activity_group_mean(self,input_data):\n","    group_day = [3,5,7,10,30]\n","    group_mean_list = []\n","\n","    for i in range(len(group_day)):\n","      group_sum = 0\n","      group_count = 0\n","      for j in range(len(input_data)):\n","        # When the 'group_day' is the same as the group day value in\n","        # the 'activity_frequency' as calculate by 'Day_ID', that '3' '5', etc\n","        # group sum and count is incremented by the frequency and count respectively.\n","        if group_day[i] == input_data[j][2]:\n","          group_sum += input_data[j][4]\n","          group_count += 1\n","      # Once all the '3', '5', or ... n is summized, that group day's mean is calculated.\n","      # Subtract one because there's an extra '0' value appended from 'activity_day_mean()'.\n","      group_mean = group_sum / (group_count - 1)\n","      group_mean_list.append([round(group_mean,2),group_day[i],group_count])\n","\n","    return group_mean_list\n","\n","#################################################\n","# Part F: Non-parametric Classification Metrics #\n","#################################################\n","# Inputs are observations and prediction columns.\n","# Assumes input has a header.\n","class classification_metrics:\n","  # true_positive  = true_positive   1  (true_positive 1 / true_positive 1 + fn4) or recall\n","  # true_negative  = true_negative   0  (true_negative 0 / true_negative 0 + false_positive 3)\n","  # false_positive = false_positive  3  predicted soreness, was not sore.\n","  #                                     false positive rate = false_positive 3 / false_positive 3 + true_negative 0\n","  # false_negative = false_negative  4  predicted not soreness, was sore\n","  # https://www.geeksforgeeks.org/metrics-for-machine-learning-model/#regression-evaluation-metrics\n","  # https://developers.google.com/machine-learning/crash-course/classification/accuracy-precision-recall\n","  '''\n","  print(P1_vert[0])\n","  print(P1_vert[1])\n","  print(P1_vert[2])\n","  # 0 6 7 8\n","  print(A1_vert[0]) # Day_ID\n","  print(A1_vert[6]) # Activity\n","  # print(A1_vert[7]) # Notes\n","  # print(A1_vert[8]) # Explaination\n","  '''\n","  def __init__(self,observations,predictions):\n","    # The input scale is 5-1 high pain to low pain (or stamina).\n","    # The original data was 1-5 high pain to low pain and was flipped\n","    # since it was confusing (except for stamina).\n","    self.observations = observations\n","    self.predictions = predictions\n","\n","  def binary_classification(self):\n","    # Returns 0 (True Negative) 1 (True Positive) if prediction\n","    # matches observation. False Positive when prediction was soreness\n","    # and observation was no soreness (3). False Negative when the prediction\n","    # was no soreness and there was soreness (4).\n","    # Also returns the count for the classifications.\n","    true_negative = 0\n","    true_positive = 0\n","    false_positive = 0\n","    false_negative = 0\n","    binary = []\n","    for i in range(1,len(self.observations)):\n","      if self.observations[i] == self.predictions[i]:\n","        result = 1\n","        true_positive += 1\n","      else:\n","        if self.predictions[i] == 'NA' or self.observations[i] == 'NA':\n","          result = 0\n","        # False positive predicted 4 or 5 (high soreness) and was 1,2,3.\n","        elif int(self.predictions[i]) > 3 and int(self.observations[i]) <= 3:\n","          result = 3\n","          false_positive += 1\n","        # False negative predicted 1,2,3 (low soreness) and was 4 or 5.\n","        elif int(self.predictions[i]) <= 3 and int(self.observations[i]) > 3:\n","          result = 4\n","          false_negative += 1\n","        else:\n","          result = 0\n","          true_negative += 1\n","      binary.append(result)\n","    return [binary,true_negative,true_positive,false_positive,false_negative]\n","\n","  def accuracy(self,binary):\n","    # Number of correct predictions / total, input is False/True 0/1.\n","    count = 0\n","    for i in binary:\n","      if i == 1:\n","        count += 1\n","    total = len(binary)\n","    result = count / total\n","    return result\n","\n","  def precision(self,true_positive,false_positive):\n","    # precision = true_positive 1 / (true_positive 1 + false_positive 3)\n","    result = true_positive / (true_positive + false_positive)\n","    return result\n","\n","  def recall(self,true_positive,false_negative):\n","    # (true_positive / true_positive + false_negative 4) or recall\n","    result = true_positive / (true_positive + false_negative)\n","    return result\n","\n","  def f1_score(self,true_positive,false_positive,false_negative):\n","    # 2 * (precision * recall) / (precision + recall)\n","    # (2 true_positive) / (2 true_positive + false_positive 3 + false_negative)\n","    result = (2 * true_positive) / ((2*true_positive) + false_positive + false_negative)\n","    return result\n","\n","  # After the previous n (10,7,5,3) days of activity frequency, use the non parametric\n","  # Wilcoxon's rank sum test to compare the two dependent or paired samples. The two\n","  # samples being compared are n days activity frequency with the entire dataset's activity\n","  # frequency. It is non-parametric because it is categorical or ordinal dataset and\n","  # not real world measurements, despite having over 30 observations.\n","  # https://www.stat.purdue.edu/~tqin/system101/method/method_wilcoxon_rank_sum_sas.htm\n","  # https://pmc.ncbi.nlm.nih.gov/articles/PMC4754273/\n","  def wilcoxon_rank_sum(self):\n","    return\n","\n","##############################################################################\n","# Part Z: Run the functions                                                  #\n","##############################################################################\n","\n","# Part A: The path of the CSV to be parsed\n","def CSV_running(path,unflipped_col):\n","  # Create the CSV_Parser class object and open the files\n","  parser = eu.CSV_Parser(path)\n","  read = parser.file_opener()\n","  # Index the comma position from the CSV and split the characters into their values\n","  comma_indexed = parser.comma_index(read, path, 0)\n","  # Get the width of columns of the commas\n","  comma_width = parser.comma_index(read, path, 1)\n","  # Sort the list into verticle columns\n","  # The P0 csv gets flipped, except for the Stm column\n","  # Divide by two - the list of comma places is doubled for the start/end value\n","  col_width = int(((comma_width - 1 ) / 2) - 1)\n","  vert = []\n","  for i in range(0,comma_width-1,2):\n","    value_list = parser.csv_value_list(comma_indexed, read, col_width, i)\n","    if unflipped_col == 0:\n","      vert.append(value_list)\n","    else:\n","      if value_list[0] in unflipped_col:\n","        vert.append(value_list)\n","      else:\n","        flip = parser.csv_flipper(value_list, col_width)\n","        vert.append(flip)\n","  return vert\n","\n","# Part D: Data visualization RGB\n","def P1_RGB_graph(P1_vert):\n","\n","  title_full = ['Stamina',\n","                'Feet','Ankle','Calves',\n","                'Knees','Quadriceps','Gluteus','Groin',\n","                'Abdominals','Lower Back',\n","                'Latissimus Dorsi','Trapezius','Shoulders',\n","                'Chest','Triceps','Biceps',\n","                'Neck','Head']\n","  P1_rgb = Graphs_rgb(P1_vert)\n","  P1_B1 = 0\n","  start_val = 3\n","  # Draws the bar charts\n","  # P1_rgb_bar = P1_rgb.rgb_timeseries_bar(title_full,start_val,P1_B1)\n","  # RGB Line Graphs by Group\n","  # Uses the position of each body part name in the title_full list\n","  P1_groups_num = [3,4,7,11,13,16,19,21]\n","  P1_title_label = ['Stamina','Lower Legs','Upper Legs','Core','Upper Back','Arms','Head']\n","  # P1_rgb_line = P1_rgb.rgb_timeseries_line(title_full,start_val,P1_groups_num,P1_title_label,P1_B1)\n","\n","  # Line graphs by upper/lower body group means\n","  def small():\n","    csv_groups_list = [[3,4],[4,7,11,13],[13,16,19,21]]\n","    legend_label = [['Stamina'],['Lower Legs','Upper Legs','Core'],['Upper Back','Arms','Head']]\n","    k0 = 0\n","    for csv_groups_num in csv_groups_list:\n","      fig, ax = plt.subplots(1, 1, layout='constrained', figsize=(11, 5), dpi=400)\n","      P1_rgb_line_smallest = P1_rgb.rgb_timeseries_small(csv_groups_num,legend_label[k0],ax)\n","      # Plot formatting\n","      plt.margins()\n","      plt.grid()\n","      plt.yticks(range(1,6),fontsize=17)\n","      plt.xticks(fontsize=17)\n","      if sum(csv_groups_num) == sum(csv_groups_list[1]):\n","        ax.legend(title='5 Day Mean', title_fontsize=19, fontsize=17)\n","        plt.title(\"Lower Body\",fontsize=19)\n","        plt.ylabel(\"Pain\",fontsize=17)\n","        #plt.savefig(\"Lower Body Pain.jpg\")\n","      elif sum(csv_groups_num) == sum(csv_groups_list[2]):\n","        ax.legend(title='5 Day Mean', title_fontsize=19, fontsize=17)\n","        plt.title(\"Upper Body\",fontsize=19)\n","        plt.ylabel(\"Pain\",fontsize=17)\n","        #plt.savefig(\"Upper Body Pain.jpg\")\n","      else:\n","        plt.ylabel(\"Stamina 5 Day Mean\",fontsize=17)\n","        #plt.savefig(\"Stamina.jpg\")\n","      k0 += 1\n","\n","  # Smallest on one graph\n","  def smallest():\n","    csv_groups_list = [[3,4],[4,12],[13,21]]\n","    legend_label = [['Stamina'],['Lower Body'], ['Upper Body']]\n","    # csv_groups_list = [[4,21]]\n","    # legend_label = [['Pain']]\n","    fig, ax = plt.subplots(1, 1, layout='constrained', figsize=(11, 5), dpi=400)\n","    k1 = 0\n","    for csv_groups_num in csv_groups_list:\n","      P1_rgb_line_smallest = P1_rgb.rgb_timeseries_small(csv_groups_num,legend_label[k1],ax)\n","      k1 += 1\n","    # Plot formatting\n","    plt.margins()\n","    plt.grid()\n","    plt.legend(title='5 Day Mean', title_fontsize=19, fontsize=17)\n","    plt.xticks(fontsize=17)\n","    plt.yticks(range(1,6),fontsize=17)\n","    plt.ylabel(\"Pain\",fontsize=17)\n","    # plt.savefig('P1_smallerest.jpg')\n","  # small()\n","  smallest()\n","\n","def B1_RGB_graph(B1_vert):\n","  title_full = ['Calories','Exercise',            # Group 0\n","              'Salt', 'Fat', 'Protein',           # Group 1\n","              'Carbohydrates', 'Alcohol Servings' # Group 3\n","              ]                                   # etc\n","  B1_rgb = Graphs_rgb(B1_vert)\n","  P1_B1 = 1\n","  start_val = 2\n","  # Part D RGB Graphs: B1.csv\n","  # B1_rgb_bar = B1_rgb.rgb_timeseries_bar(title_full,start_val,P1_B1)\n","  # RGB Line Graphs by Group for B0.csv\n","  # Uses the position of each title in the title_full list\n","  B1_groups_num = [2,3,4,8,9]\n","  B1_title_label = ['Calories','Exercise','Nutrients','Alcohol Servings']\n","  # Line graph is not appropriate for calories, exercise, and alcohol servings\n","  B1_rgb_line = B1_rgb.rgb_timeseries_line(title_full,start_val,B1_groups_num,B1_title_label,P1_B1)\n","\n","# A0_vert.tsv or A1_vert.tsv\n","def A1_RGB_graph(A1_vert):\n","  # Part D RGB Graphs: A0.tsv\n","  A1_sort = Graphs_sort(A1_vert)\n","  # Calculates the duration of each activity.\n","  A1_sort_duration = A1_sort.sort_time(A1_sort.data[6],A1_sort.data[4],A1_sort.data[5])\n","  # Removes endings for similar words such as: 'Walk', 'Walks', 'Walked', 'Walking'.\n","  A1_activity_filter = A1_sort.filter_stop(A1_sort.data[6])\n","\n","  # Time_ID, Date, Duration, Activity_filtered\n","  # Part of the duration times calories burned (used built in sorted)\n","  # not A1_sort.data[3][i], A1_sort.data[6][i]\n","  A1_sort_column = [A1_sort.data[1],A1_sort_duration,A1_activity_filter]\n","  # A1_sort_duration[i] * calories burned doing A1_sort.data[6][i]\n","  # Transpose\n","  A1_sort_rows = list(zip(*A1_sort_column))\n","  A1_sorted_rows = sorted(A1_sort_rows[1:], key=lambda row: row[2])\n","\n","  # Sorts the list using an implementation of merge sort.\n","  ord_list = ['ord_list'] + [ord(A1_activity_filter[x][0]) for x in range(1,len(A1_activity_filter))]\n","  A1_sort_merged = A1_sort.sort_ascii(ord_list,A1_activity_filter,A1_sort.data[1],A1_sort_duration)\n","  # Finds the unique occurances of each word in 'Activity'.\n","  A1_sort_unique = A1_sort.sort_unique_words(A1_sort_merged[0])\n","\n","  # Other part of the duration times calories burned\n","  calories_out_min_path = \"/content/calories_burned_calculator.csv\"\n","  calories_out_act = CSV_running(calories_out_min_path,0)\n","  # TODO merge sort by int\n","  calories_out_min = calories_out_act[1][1:]\n","  A1_sorted_calories = []\n","  for i in range(len(A1_sorted_rows)):\n","    for j in range(len(A1_sort_unique[1:])):\n","      if A1_sorted_rows[i][2] == A1_sort_unique[1:][j]:\n","        # print(A1_sorted_rows[i][1],calories_out_min[j])\n","        calories_out = int(A1_sorted_rows[i][1]) * float(calories_out_min[j])\n","        A1_sorted_calories.append((int(A1_sorted_rows[i][0]),A1_sorted_rows[i][2],A1_sorted_rows[i][1],float(calories_out_min[j]),calories_out))\n","  # Sort by the ID.\n","  A1_calories = sorted(A1_sorted_calories, key=lambda row: row[0])\n","  # Transpose back to columns.\n","  A1_calories_columns = [list(col) for col in zip(*A1_calories)]\n","  # (from A1-small.csv) ID, Activity, Duration, Calories Out per minute, Calories Out Activity, Date,\n","  # (from B1.csv 100) ID, Date, Calories In, Exercise Intensity Scale, Alcohol Servings\n","  A1_calories_columns.append(A1_sort.data[3][1:])\n","  for k in A1_vert[-1]:\n","    A1_calories_columns.append(k[1:])\n","\n","  # Bins the sorted list using the unique words.\n","  A1_sort_bin = A1_sort.sort_unique_bin(A1_sort_unique,A1_sort_merged)\n","\n","  # Merges the bins based on if the first word in the string are the same.\n","  # i.e. 'Eat' <- 'Eat 1' <- 'Eat 2' <- 'Eat 3'\n","  A1_sort_similar = A1_sort.merge_similar_activities(A1_sort_bin)\n","  A1_sort_similar_splice = A1_sort.merge_activities_splice(A1_sort_similar)\n","\n","  # Sort the values for each horizontal bar graph.\n","  A1_sort_similar_2 = A1_sort.merge_sort_int(A1_sort_similar_splice[2],A1_sort_similar_splice[0])\n","\n","  A1_sort_graph = Graphs_rgb(0)\n","  # A1_sort_graph.rgb_timeseries_frequency(A1_sort_similar_2)                     # ( 2, 0 )\n","  A1_sort_similar_1 = A1_sort.merge_sort_int(A1_sort_similar_splice[1],A1_sort_similar_splice[0])\n","  # A1_sort_graph.rgb_timeseries_duration(A1_sort_similar_1)                      # ( 0, 1 )\n","\n","  # Calories out by Activity\n","  A1_sort_graph.rgb_timeseries_calories_out(A1_calories_columns)\n","\n","  '''\n","  # Total activity mean.\n","  A1_sort_duration_mean = []\n","  for i in range(len(A1_sort_similar_splice[1])):\n","    duration_mean = A1_sort_similar_splice[1][i] / A1_sort_similar_splice[2][i]\n","    A1_sort_duration_mean.append(duration_mean)\n","  A1_sort_similar_3 = A1_sort.merge_sort_int(A1_sort_duration_mean,A1_sort_similar_splice[0])\n","  A1_sort_graph.rgb_timeseries_mean(A1_sort_similar_3)                          # ( 0,(1/2) )\n","\n","  # Daily mean.\n","  A1_sort_daily_mean = []\n","  for i in range(len(A1_sort_similar_splice[1])):\n","    duration_mean = (A1_sort_similar_splice[1][i] / 100) * 60\n","    # Activity, Total Hours, Occurences, duration_mean\n","    print(A1_sort_similar_splice[0][i], A1_sort_similar_splice[1][i], A1_sort_similar_splice[2][i], duration_mean)\n","    A1_sort_daily_mean.append(duration_mean)\n","  A1_sort_similar_4 = A1_sort.merge_sort_int(A1_sort_daily_mean,A1_sort_similar_splice[0])\n","  A1_sort_graph.rgb_timeseries_daily_mean(A1_sort_similar_4)                    # ( 0,((1/2) / 100) * 60)\n","  '''\n","\n","# Part F: Predictions vs Observed pain values using classification metrics.\n","def P1_Classification_RGB_graph(P1_vert,P1_vert_predictions):\n","\n","  # B1.csv - Nutrition - binary calories high and low -> above/below 2500\n","  # - Mean number of activities per day over 3-14 days\n","  #     - Exclude 09/09-09/13 since it was recorded with excessive detail.\n","  # - Not stretching in the one or two days afterward.\n","  # - Stretching too frequently in the one or two days afterward.\n","\n","  # Days of Interest :\n","  # Stamina for 08/27-0903 (value 4) except 08/29 (value 2) and abs (4) on 08/31.\n","      # Stamina for 09/13. Exclude 09/09-09/13 since it was recorded with excessive detail.\n","  # Stamina for 09/19-09/22 (value 4) except 09/21 (value 2).\n","  # The goal is to find an appropriate balance for exercise and not moving\n","  # by examining the frequency of Activities before these decreases.\n","\n","  # 'Day_ID' remove 49-53 for average graphing because they were recorded\n","  # differently and induce outliers. ['909','910','911','912','913']\n","  for P1 in range(len(P1_vert_predictions)):\n","    del P1_vert_predictions[P1][50:55]\n","    del P1_vert[P1][50:55]\n","  # Remove these dates: ['909','910','911','912','913']\n","  # in A1_vert[0], A1_vert[3]\n","  del A1_vert[0][271:326]\n","  del A1_vert[3][271:326]\n","  # Accuracy, Precision, Recall, F1\n","  # Uses F1 since RMSE is for regression prediction models. The pain scale\n","  # is numerical and is equivilent to nominal categories.\n","  title_full = ['','','',\n","  'Stamina',\n","  'Feet','Ankle','Calves',\n","  'Knees','Quadriceps','Gluteus','Groin',\n","  'Abdominals','Lower Back',\n","  'Latissimus Dorsi','Trapezius','Shoulders',\n","  'Chest','Triceps','Biceps',\n","  'Neck','Head']\n","  # todo classification_metrics\n","  # wilcoxon_rank_sum\n","  for i in range(3,len(P1_vert)):\n","    '''\n","    print('Pain Scale')\n","    print(P1_vert[i])\n","    print('Classification')\n","    class_met = classification_metrics(P1_vert[i],P1_vert_predictions[i])\n","    binary = class_met.binary_classification()\n","    print(binary[0])\n","    print()\n","    # i is the pain scale 'Day_ID' (1-101) for A1 (1-350ish) 'did'\n","    print(A1_vert[0]) # 'Day_ID\n","    print(A1_vert[1])\n","    print(A1_vert[6]) # 'Activity'\n","    print()\n","    '''\n","\n","    A1_graphs_sort = eu.Graphs_sort(A1_vert)\n","    A1_filter = A1_graphs_sort.filter_stop(A1_graphs_sort.data[6])\n","\n","    '''\n","    A1_graphs_sort = Graphs_sort(data)\n","    A1_graphs_sort.filter_stop(A1_graphs_sort.data[])\n","    acc_binary = class_met.accuracy(binary[0])\n","    # header : print(P1_vert[i][0])\n","    print('Accuracy', ' = ', acc_binary)\n","    precision_binary = class_met.precision(binary[2],binary[3]) # tsp fp\n","    print('Precision', ' = ', precision_binary)\n","    print('tsp', ' ', binary[2])\n","    print('fp', ' ', binary[3])\n","    print()\n","    recall_binary = class_met.recall(binary[2],binary[4]) # tsp fn\n","    print('Recall', ' = ', recall_binary)\n","    print('tsp', ' ', binary[2])\n","    print('fp', ' ', binary[3])\n","    print()\n","    f1_score_binary = class_met.f1_score(binary[2],binary[3],binary[4]) # tsp fp fn\n","    print('F1 Score', ' = ', f1_score_binary)\n","    print('tsp', ' ', binary[2])\n","    print('fp', ' ', binary[3])\n","    print('fn', ' ', binary[4])\n","    print()\n","    print()\n","    print()\n","    '''\n","\n","  return\n","\n","# Part E and F: P1.csv with part F accuracy metrics, activity reverse by group,\n","# and activity reverse by entry.\n","def A1_daily_RGB_graph(P1_vert,P1_vert_predictions,A1_vert):\n","  # Edited five days to remove overly detailed entries called 'A1-small.csv'\n","  # original is 'A1.csv' - ['909','910','911','912','913']\n","  A1_Graphs_sort = Graphs_sort(A1_vert)\n","  days_pain = []\n","  days_not_pain = []\n","  all_days = []\n","  # Loop returns the bodily part, number of days, and erroneous pain or\n","  # stamina values start and end from the erroneous observation minus\n","  # number of days. Also returns the days that were not a pain.\n","  for i in P1_vert[3:]:\n","    reverse_days = A1_Graphs_sort.erroneous_values(i)\n","    if len(reverse_days[0]) > 2:\n","      days_pain += reverse_days[0]\n","      days_not_pain += reverse_days[1]\n","      all_days += reverse_days[2]\n","\n","  # Returns the frequency of activities for every day (discards the first 10).\n","  A1_activity_splice = A1_Graphs_sort.activity_frequency_splice()\n","  A1_activity_pain = A1_Graphs_sort.activity_reverse(days_pain,A1_activity_splice)\n","  A1_activity_not_pain = A1_Graphs_sort.activity_reverse(days_not_pain,A1_activity_splice)\n","  A1_activity_all = A1_Graphs_sort.activity_reverse(all_days,A1_activity_splice)\n","\n","  # Calcualtes the mean for each reverse day means, then graph '3' on x with the sum\n","  # of the erroneous means divided by their count on the y against non pain\n","  # means and all the days mean. 'y' is labeled 'Activity Frequency'.\n","  A1_pain_group_mean = A1_Graphs_sort.activity_group_mean(A1_activity_pain)\n","  A1_not_pain_group_mean = A1_Graphs_sort.activity_group_mean(A1_activity_not_pain)\n","  A1_all_group_mean = A1_Graphs_sort.activity_group_mean(A1_activity_all)\n","\n","  # Graphing section.\n","  # Summarized pain, not pain, and all data means for 3,5,7,10,and 30 days before the event.\n","  A1_graph_rgb = Graphs_rgb([])\n","  A1_reverse_mean_category = A1_graph_rgb.rgb_reverse_category(A1_pain_group_mean,A1_not_pain_group_mean,A1_all_group_mean)\n","\n","  # Mean of every reverse splice for each day.\n","  A1_day_mean_category = A1_graph_rgb.rgb_reverse_day_mean(A1_activity_pain,P1_vert)\n","\n","  '''\n","  # Graphing the prediction and observation along with classification metrics.\n","  # Usage is from 'P1_Classification_RGB_graph()'\n","  title_full = [#'','','',\n","  'Stamina',\n","  'Feet','Ankle','Calves',\n","  'Knees','Quadriceps','Gluteus','Groin',\n","  'Abdominals','Lower Back',\n","  'Latissimus Dorsi','Trapezius','Shoulders',\n","  'Chest','Triceps','Biceps',\n","  'Neck','Head']\n","  for j in range(8,11\n","                 #,len(P1_vert_predictions)\n","                 ):\n","    class_met = classification_metrics(P1_vert[j],P1_vert_predictions[j])\n","    binary = class_met.binary_classification()\n","    acc_binary = class_met.accuracy(binary[0])\n","    precision_binary = class_met.precision(binary[2],binary[3]) # tsp fp\n","    recall_binary = class_met.recall(binary[2],binary[4]) # tsp fn\n","    f1_score_binary = class_met.f1_score(binary[2],binary[3],binary[4]) # tsp fp fn\n","    classification_list = [title_full[j-3],P1_vert[j][0],acc_binary,precision_binary,recall_binary,f1_score_binary]\n","    P1_graph_rgb = Graphs_rgb([])\n","    P1_graph_rgb.rgb_prediction_observation(P1_vert_predictions[j],P1_vert[j],P1_vert_predictions[1],classification_list)\n","    '''\n","  return\n","\n","# One month of May, 2024 observations\n","P0_path = \"/content/P0.csv\"\n","B0_path = \"/content/B0.csv\"\n","# A0 is a TSV because there are blank cells\n","A0_path = \"/content/A0.tsv\"\n","# P0_unflipped_col = ['ID','Date','Day','Stm']\n","# P0_vert = CSV_running(P0_path,P0_unflipped_col)\n","# B0_vert = CSV_running(B0_path,0)\n","# A0_vert = CSV_running(A0_path,0)\n","\n","# Four months of July-October observations\n","# P1.csv contains the pain scale and B1.csv contains the food records\n","P1_path = \"/content/P1-Observations-PaperFigures.csv\"\n","P1_path_predictions = \"/content/P1-Prediction-PaperFigures.csv\"\n","B1_path = \"/content/B1.csv\"\n","# A1 is a tsv because of blank cells\n","# A1_path = \"/content/A1.tsv\" # The full dataset.\n","A1_path = \"/content/A1-small.tsv\"\n","# List of columns to not be flipepd\n","P1_unflipped_col = ['ID','Date','Day','Stm','Notes','Notes2']\n","P1_vert = CSV_running(P1_path,P1_unflipped_col)\n","P1_vert_predictions = CSV_running(P1_path_predictions,P1_unflipped_col)\n","# B1_vert = CSV_running(B1_path,0)\n","A1_vert = CSV_running(A1_path,0)\n","# P1_RGB_graph(P0_vert)\n","# P1_RGB_graph(P1_vert)\n","# B1_RGB_graph(B0_vert)\n","# B1_RGB_graph(B1_vert)\n","# A1_RGB_graph(A0_vert)\n","# This is for calories out graph.\n","# A1_vert.append(B1_vert[2:4])\n","# A1_vert[-1].append(B1_vert[8])\n","# A1_RGB_graph(A1_vert)\n","# P1_Classification_RGB_graph(P1_vert,P1_vert_predictions)\n","A1_daily_RGB_graph(P1_vert,P1_vert_predictions,A1_vert)\n"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":6,"status":"ok","timestamp":1744137032714,"user":{"displayName":"David Leifer","userId":"06279506333224389759"},"user_tz":300},"id":"SLyAYj_xtzdg","outputId":"3bb4744a-366f-4183-a0ca-7f695d31af9e"},"outputs":[{"name":"stdout","output_type":"stream","text":["[[[1], ['b']]]\n"]}],"source":["abc = [\n","        [[0], ['a']],\n","        [[1], ['b']],\n","        [[2], ['c']],\n","        [[3], ['d']],\n","        [[4], ['e']],\n","        [[5], ['f']],\n","        [[6], ['g']],\n","        [[7], ['h']],\n","        [[8], ['i']],\n","        [[9], ['j']],\n","                      ]\n","# for i in range(10):\n","print(abc[1:2])"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":9,"status":"ok","timestamp":1744769169351,"user":{"displayName":"David Leifer","userId":"06279506333224389759"},"user_tz":300},"id":"kti4uK-eVPeZ","outputId":"1c1bc210-f9b0-4b10-b49e-62551d97b986"},"outputs":[{"name":"stdout","output_type":"stream","text":["34\n","5\n"]}],"source":["a = '1234'\n","b = '567'\n","c = '89'\n","\n","\n","if len(a) == 4:\n","  end_sub = a[2:]\n","  print(end_sub)\n","\n","if len(b) == 3:\n","  end_sub = b[:1]\n","  print(end_sub)\n","\n","if len(c) == 2:\n","  end_sub = c"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"bNU5wcEd0AeC"},"outputs":[],"source":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6wounMFJaZT3"},"outputs":[],"source":[]}],"metadata":{"colab":{"provenance":[{"file_id":"1fHIWbrpk4NMYcse3Xdkb-S8XiS2pxzJm","timestamp":1721260308720},{"file_id":"1STKhtVVaknUZiohwWLdfyoZ3zg6Veimx","timestamp":1721260179755}],"authorship_tag":"ABX9TyM5iZmeagTmQfLbGAtATuhF"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}