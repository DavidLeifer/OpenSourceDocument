{"cells":[{"cell_type":"code","execution_count":48,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":1000},"executionInfo":{"elapsed":267,"status":"ok","timestamp":1750105896614,"user":{"displayName":"David Leifer","userId":"06279506333224389759"},"user_tz":300},"id":"IxtfVwAjhyaV","outputId":"762b0e99-9107-43fb-9d91-c134847dff7f"},"outputs":[{"output_type":"stream","name":"stdout","text":["['Stm', 13, 3, 17, 5.67]\n","['Stm', 38, 3, 24, 8.0]\n","['Stm', 38, 5, 37, 7.4]\n","['Stm', 38, 7, 46, 6.57]\n","['Stm', 38, 10, 72, 7.2]\n","['Stm', 53, 3, 23, 7.67]\n","['Stm', 53, 5, 32, 6.4]\n","['Stm', 53, 7, 36, 5.14]\n","['Stm', 53, 10, 47, 4.7]\n","['Stm', 53, 30, 173, 5.77]\n","['Stm', 61, 3, 14, 4.67]\n","['Stm', 61, 5, 23, 4.6]\n","['Stm', 61, 7, 33, 4.71]\n","['Stm', 61, 10, 59, 5.9]\n","['Stm', 61, 30, 163, 5.43]\n","['Qua', 16, 3, 17, 5.67]\n","['Qua', 16, 5, 30, 6.0]\n","['Qua', 19, 3, 19, 6.33]\n","['Qua', 19, 5, 32, 6.4]\n","['Qua', 19, 7, 42, 6.0]\n","['But', 13, 3, 17, 5.67]\n","['Gro', 16, 3, 17, 5.67]\n","['Gro', 16, 5, 30, 6.0]\n","['Gro', 21, 3, 17, 5.67]\n","['Gro', 21, 5, 29, 5.8]\n","['Gro', 21, 7, 42, 6.0]\n","['Gro', 21, 10, 59, 5.9]\n","['Abs', 40, 3, 21, 7.0]\n","['Abs', 40, 5, 36, 7.2]\n","['Abs', 40, 7, 49, 7.0]\n","['Abs', 40, 10, 69, 6.9]\n","['Abs', 40, 30, 186, 6.2]\n","['Abs', 53, 3, 23, 7.67]\n","['Abs', 53, 5, 32, 6.4]\n","['Abs', 53, 7, 36, 5.14]\n","['Abs', 53, 10, 47, 4.7]\n","['Abs', 53, 30, 173, 5.77]\n","['Nec', 51, 3, 17, 5.67]\n","['Nec', 51, 5, 21, 4.2]\n","['Nec', 51, 7, 29, 4.14]\n","['Nec', 51, 10, 42, 4.2]\n","['Nec', 51, 30, 169, 5.63]\n","['Hea', 47, 3, 9, 3.0]\n","['Hea', 47, 5, 16, 3.2]\n","['Hea', 47, 7, 26, 3.71]\n","['Hea', 47, 10, 47, 4.7]\n","['Hea', 47, 30, 170, 5.67]\n","['Hea', 65, 3, 18, 6.0]\n","['Hea', 65, 5, 28, 5.6]\n","['Hea', 65, 7, 36, 5.14]\n","['Hea', 65, 10, 50, 5.0]\n","['Hea', 65, 30, 163, 5.43]\n"]},{"output_type":"display_data","data":{"text/plain":["<Figure size 800x600 with 1 Axes>"],"image/png":"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8pNtAAAAkB2yfo8kAAAApgZBEgAAAJYQJAEAAGAJQRIAAACWECQBAABgiS2DZDgc1q233iqv16tp06Zp4cKFuvPOO6MuLG6M0W233SaPx6Np06bpwgsv1L59+8b8e/39/fqbv/kbORwO7dmzJ0WziG2i+X366ae65ZZbdOaZZ2rGjBmaM2eOrrrqKn3wwQdRf6ejo0NLly7VSSedpFmzZum6667TkSNH0jGlUXp7e/X9739f8+fP17Rp07R48WK98sorI/f/+te/1kUXXaRZs2bFfF6uv/56LVy4UNOmTdPs2bO1fPlyvfHGGymcRWzjzS/e52/dunVavHixpk+frpNOOikNs4gtGevg888/L4fDMebt2NdCOsQzv3heo319fbrxxhs1a9YsnXjiibr88sv14YcfpnAmsSVjjj09PfrHf/xHnX766Zo2bZrmzZunm266ScFgMMWzGS2e+d1+++1atGiRZsyYoZkzZ+rCCy/Uyy+/HPV3Mnk9TMZ29MEHH9TXv/51FRcXy+Fw6PDhw6mbQBwmmqOdtzNSct4rFixYMGpu69evT90kjA2tW7fOzJo1yzz11FPG7/ebxx57zJx44onmJz/5yciY9evXG7fbbZ544gmzd+9ec+mllxqv12s++eSTUX/vpptuMsuWLTOSzO7du1M4k7FNNL/Dhw+bCy+80DzyyCPmjTfeMDt37jRVVVXm3HPPHfkb77//vpk5c6a54YYbzBtvvGHa29vN4sWLzeWXX56uaUVZsWKF8fl85oUXXjD79u0zDQ0Npri42Lz33nvGGGN+8YtfmMbGRrNx48aYz8uGDRvMCy+8YPx+v3n11VdNbW2tKS8vN4ODgymezWjjzS+e588YY2677TZz3333mZtvvtm43e70TCSGZKyD/f39JhAIRN2+853vGK/XayKRSLqmZoyJb37xvEZvuOEGU15ebrZt22Z27dplvvzlL5vFixencCaxJWOOr732mvnmN79pnnzySfP222+bbdu2mS984QsZsZ2JZ34PPfSQ+Z//+R/zzjvvmM7OTrNmzRpTXFxsuru7R8Zk8nqYjO3o/fffb5qamkxTU5ORZD7++OPUTmICE83RztsZY5LzXjF//nxzxx13RM3xyJEjKZuDLYPkJZdcYq699tqoZd/85jfNypUrjTHGRCIRU1ZWZu65556R+w8fPmwKCwvN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\n"},"metadata":{}}],"source":["def todo(self):\n","  # List of primary issues\n","  # todo    description                                   hours   progress      Note\n","  #\n","  # todo0   A01.csv skate, long, downhill, juggling,      83      Completed\n","  #         running mean duration by category.\n","  #\n","  # todo1   A01.csv category by day of the week or        .25     DNF           Hours are spread throughout the day.\n","  #         time of day i.e. morning, afternoon, night\n","  #         or blocks of 3.\n","  #\n","  # todo2   A01.csv nltk the 'Explanation' and 'Notes'                          Word frequency might be useful to find specific muscles.\n","  #         sections? Manual descriptions are already                           Topic analysis is included in 'Activity'. Sentiment analysis is\n","  #         included in the write-up.                                           redundant since 'Notes' is informational and not opinion.\n","  #\n","  # todo3   Another tutorial chapter on merge sort.               TODO\n","  #         Compare with Python's built-in len(),\n","  #         sort(), and replace().\n","  #\n","  # todo4   The graphing part could be included in        .25     DNF           This is a good project to learn syntax and documentation since it's visual.\n","  #         Chapter 1 with pandas and SciPy.\n","  #\n","  # todo5   A01.csv longboard and running distance.       .5      DNF           Running occured around 5 times and longboarding was recorded with time.\n","  #\n","  #\n","  # todo6   P0P1B0B1.csv timeseries graphing.             45.5    Completed\n","  #\n","  # todo7   P1.csv manual vs observed prediction          44.5    Processing    Graph reverse time. Wilcoxon statistical test to compare\n","  #         accuracy F1.                                                        frequency target mean with total mean. Graph prediction, observation with\n","  #                                                                             precision, recall, F1 score.\n","  #\n","  # todo8   B01.csv Pearson-Correlation and day-          2       Completed     Found that there was not correlation between parametric variables.\n","  #         delayed between calories, alcohol, exercise.                        An index similar to ENSO is redundant since there were no consecutive\n","  #                                                                             observations over 4 alcohol or excessive (calorie - calorie burned).\n","  #\n","  # todo9   A01P01B01 moving window spearman              .5      DNF           Would have to sort these for rank, which was completed in todo0.\n","  #         correlation between activity, duration,                             Square the difference between each numbers rank and sum all the numbers,\n","  #         time of day, pain, nutrients,                                       multiply by 6, divide by (number times (number squared minus one).\n","  #         calories, alcohol.                                                  1 - calculated number.\n","  #\n","  # todo10  tbd data filling and automatic predictions.   0       DNF\n","  #         idk if thats another chapter or avoided.\n","  #\n","  # todo11  Manual weather observations and PRISM data    0       DNF\n","  #         will be in a different GitHub to avoid\n","  #         confusion.\n","  #\n","  # Time spent at a computer programming\n","  # Total estimate  :\n","  # Total actual    :\n","  #\n","  # Purpose\n","  # The goal of writing this is to waste as much time as possible in between\n","  # exercise to avoid overtraining while retaining logical thought process\n","  # during long stretches of unemployment. These were written on a computer\n","  # with a 1.5-2 hour battery to restrict excessive\n","  # programming by limiting hardware access.\n","  #\n","  # Abstract\n","  # Python with C-like syntax is used for data manipulation and\n","  # graphing arrays are handled without dictionaries. The only\n","  # library used is Matplotlib for RGB graphing and to avoid writing a image or\n","  # video format that would likely spread misinformation. An implementation of\n","  # the merge sort algorithm was used to alphabetize exercise activity for\n","  # binning and graphing frequency by unique type. The built-in Python methods\n","  # for 'replace', 'split', 'len', and 'sort' were manually written for\n","  # learning purposes.\n","\n","  # Start date: 20250125\n","  # End date:\n","\n","  # Below is an exhaustive list of secondary issues.\n","\n","  # List of secondary issues\n","  # todo   description                                                  progress\n","  # todo0  rewrite parser for unicode csv str/int.\n","  # todo1  Stats class avoid NA, NAAN, -9999, etc.\n","  # todo2  refractor RGB_graphs.\n","  # todo3  monthly means on bar graphs.\n","  # todo4  organize merge_sort into another classe.                     Complete\n","  # todo5  modify merge sort to accept entire CSV.                      Class\n","  # todo6  Handle multi word activity descriptions consistently.        Class\n","  # todo7  switch the second capital letter to lower case if exists.    Class\n","  # todo8  unchain the four merge sort functions.                       Class\n","\n","  return\n","\n","# import sys\n","# for path in sys.path:\n","#   print(path)\n","import matplotlib\n","import matplotlib.pyplot as plt\n","import exercise_module as eu\n","# eu.test_function()\n","# print(sys.version)\n","# 3.10.12 (main, Mar 22 2024, 16:50:05) [GCC 11.4.0]\n","# 3.11.11 (main, Dec  4 2024, 08:55:07) [GCC 11.4.0]\n","\n","# In development.\n","###############################################\n","# Part D: Data visualization with a RGB graph #\n","###############################################\n","# Matplotlib for color because otherwise you would have\n","# to write hardware code to avoid using Python or C libraries.\n","\n","class Graphs_rgb: # 'Graphs_rgb_dev()' in 'exercise_module.py'\n","  # Initialize the input variables\n","  def __init__(self, data):\n","    self.data = data\n","\n","  # Todo wilcoxon to compare means.\n","  def rgb_reverse_category(self,pain,not_pain,all_data):\n","\n","    x = [i[1] for i in pain]\n","    y1 = [j[0] for j in pain]\n","    y1n = [j[2] for j in pain]\n","\n","    y2 = [k[0] for k in not_pain]\n","    y2n = [k[2] for k in not_pain]\n","\n","    y3 = [l[0] for l in all_data]\n","    y3n = [l[2] for l in all_data]\n","\n","    plt.figure(figsize=(8, 6))\n","    plt.scatter(x, y1, label='Pain', marker='+')\n","    plt.scatter(x, y2, label='Not Pain', marker='_')\n","    plt.scatter(x, y3, label='All Data', marker='.')\n","    plt.xlabel('Days in Reverse', fontsize=10)\n","    plt.ylabel('Mean Daily Activities', fontsize=10)\n","    plt.title('Activites Before Pain',fontsize=12)\n","    for iter, mean in enumerate(y1):\n","      if mean > 6.5:\n","        bx_pos = x[iter] - 1.5\n","        by_pos = mean - .1\n","      else:\n","        bx_pos = x[iter] + 1.5\n","        by_pos = mean + .1\n","      box_str = 'N. ' + str(y1n[iter])\n","      plt.text(\n","          bx_pos,\n","          by_pos,\n","          box_str,\n","          ha=\"center\",\n","          va=\"bottom\",\n","          size=8,\n","          bbox=dict(facecolor=\"white\", edgecolor=\"black\", boxstyle=\"round\", alpha=0.75),\n","      )\n","    plt.xticks(x)\n","    plt.ylim(5.1,6.75)\n","    plt.grid()\n","    plt.margins(y=0.01)\n","    plt.legend(loc='upper left')\n","    plt.show()\n","\n","    # plt.savefig('P1-0 Activity Frequency Mean July-October, 2024' + '.jpg')\n","    return\n","\n","  # Prediction vs observation and accuracy, precision, F1 score.\n","  # Input is prediction, observation, date, classification scores.\n","  def rgb_prediction_observation(self,prediction,observation,date,classification_list):\n","    x = []\n","    y1 = []\n","    y2 = []\n","    y3 = []\n","    # Filter 'NA'.\n","    for j in range(1,len(prediction)):\n","      if len(date[j]) == 3:\n","        month = date[j][0:1]\n","        day = date[j][1:]\n","      else:\n","        month = date[j][0:2]\n","        day = date[j][2:]\n","      split_date = month + '/' + day\n","      if prediction[j] == 'NA' or observation[j] == 'NA':\n","        y1.append(None)\n","        y2.append(None)\n","        y3.append(None)\n","        x.append(split_date)\n","      else:\n","        if prediction[j] == observation[j]:\n","          #print(prediction[j],observation[j],date[j])\n","          y1.append(int(prediction[j]))\n","          y2.append(None)\n","          y3.append(None)\n","          x.append(split_date)\n","        else : # prediction[j] != observation[j]\n","          y1.append(None)\n","          y2.append(int(prediction[j]))\n","          y3.append(int(observation[j]))\n","          x.append(split_date)\n","\n","    plt.figure(figsize=(18, 6))\n","    plt.scatter(x, y1, label='Same', marker='.')\n","    plt.scatter(x, y2, label='Prediction', marker='o')\n","    plt.scatter(x, y3, label='Observation', marker='o')\n","    plt.ylim(0,6)\n","    x_label = [i for i in x[::5]]\n","    plt.xticks(x_label, fontsize=8)\n","    plt.xlabel('Date (2024)', fontsize=10)\n","    if prediction[0] == 'Stm':\n","      by_pos = .8\n","      plt.ylabel('Stamina', fontsize=10)\n","      plt.legend(loc='lower left',fontsize=8,borderaxespad=1.2)\n","    else:\n","      by_pos = 5.75\n","      plt.ylabel('Pain', fontsize=10)\n","      plt.title(classification_list[0])\n","      plt.legend(loc='upper left',fontsize=8,borderaxespad=1.2)\n","\n","    bx_pos = '10/26' # x[-1]\n","    box_label = ['','','Accuracy: ', 'Precision: ', 'Recall: ', 'F1 Score: ']\n","    box_str = ''\n","    for k in range(2,len(classification_list)):\n","      box_subset_str = box_label[k] + str(round(classification_list[k],2))\n","      if k < len(classification_list) - 1:\n","        box_str += box_subset_str + '\\n'\n","      else:\n","        box_str += box_subset_str\n","\n","    plt.text(\n","        bx_pos,\n","        by_pos,\n","        box_str,\n","        ha=\"left\",\n","        va=\"top\",\n","        size=8,\n","        bbox=dict(facecolor=\"white\", edgecolor=\"grey\", boxstyle=\"round,pad=0.5\", alpha=0.5))\n","    plt.grid()\n","    plt.margins(y=0.01)\n","    return\n","\n","  def rgb_reverse_day_mean(self,input_data,P1_data):\n","    x = [i[1] for i in input_data]\n","    y = [j[4] for j in input_data]\n","\n","    # Return the date\n","    x = []\n","    for k in range(len(input_data)):\n","      splice = input_data[k][1] + 1\n","      x.append(P1_data[1][splice])\n","      #print(x[k], y[k], input_data[k])\n","\n","    plt.figure(figsize=(8,6))\n","    plt.scatter(x, y)\n","    # plt.scatter(x, y2, label='Prediction', marker='o')\n","    # plt.scatter(x, y3, label='Observation', marker='o')\n","    # plt.ylim(0,6)\n","\n","    ''' todo: category graphs\n","    dm = 'Day_ID' mean for [3,5,7...n]\n","\n","     |\n","     |             dm\n","     |     dm                                   n\n","     |                       dm      dm\n","     |___________________________________\n","        'Stm'13  'Qua'38  'etc'53  'etc'61  ... n\n","    '''\n","    return\n","\n","# In development.\n","#################################################\n","# Part E: Part D visualization helper functions #\n","#################################################\n","# Merge sort is the fastest for worst case scenario sorting: N log(n)\n","# Implementation is from W3 and modified for AZ with ascii ord():\n","# https://www.w3schools.com/dsa/dsa_algo_mergesort.php\n","# Bubble sort is the fastest for almost sorted lists O(n)\n","# https://www.w3schools.com/dsa/dsa_timecomplexity_bblsort.php\n","# Python's built-in sort() function uses Tim Sort which uses a hybrid\n","# Insertion and Merge. Insertion is similar to Bubble with the same\n","# Time and Space complexity with worst case O(n^2) and best O(n).\n","class Graphs_sort:\n","  # Initialize the input variables\n","  def __init__(self, data):\n","    self.data = data\n","\n","  # Returns the abnormal pain entry.\n","  def erroneous_values(self,P1_vert_column):\n","    erroneous_values = [[P1_vert_column[0],'NA']]\n","    non_erroneous_values = [[P1_vert_column[0],'NA']]\n","    all_values = [[P1_vert_column[0],'NA']]\n","    for i in range(len(P1_vert_column)):\n","      if len(P1_vert_column[i]) > 1:\n","        continue\n","      # Append all values to calculate overall mean.\n","      all_values.append([P1_vert_column[i], i-1])\n","      # Not stamina and greater than 4 pain values and 'Day_ID' get sent\n","      # to the list of lists.\n","      if P1_vert_column[0] != 'Stm' and int(P1_vert_column[i]) > 3:\n","        erroneous_values.append([P1_vert_column[i], i-1])\n","      # If it is stamina, check for values 2 and less.\n","      elif P1_vert_column[0] == 'Stm' and int(P1_vert_column[i]) < 3:\n","        erroneous_values.append([P1_vert_column[i], i-1])\n","      else:\n","        # Otherwise it is a normal value.\n","        non_erroneous_values.append([P1_vert_column[i], i-1])\n","    return [erroneous_values,non_erroneous_values,all_values]\n","\n","  # Calculates the activity frequency for each day in ~ 500 iterations.\n","  # Returns 'Day_ID', 'start', and 'end' for splicing in 'activity_reverse()'.\n","  def activity_frequency_splice(self):\n","    # Skips the first ten values, 'Day_ID' is '10' in P1.csv and\n","    # 'start' is the 'Time_ID' in A1.tsv. The first 10 days are discarded\n","    # because they are why the information was collected.\n","    start = 53\n","    activity_frequency = []\n","    # The 'data' is from the function's class and needs a boilerplate\n","    # value appended to return the entire length of the 'data' list.\n","    data = self.data[0]\n","    data.append('100')\n","    for i in range(start,len(data)):\n","      # Checks 'Day_ID' P1.csv against 'Time_ID' from A1.tsv.\n","      # If 'Day_ID' is not '' or the values in A1.tsv,\n","      # they must by an integer (as long as the first value\n","      # header 'Day_ID' is ignored).\n","      if len(data[i]) > 0:\n","        day_id = int(data[i])\n","        activity_frequency.append([day_id-1, start, i])\n","        # 'start' is set to the 'i' or the iterator, which resumes checking\n","        # the length of A1.tsv.\n","        start = i\n","    # Deletes the null first value.\n","    del activity_frequency[0]\n","    return activity_frequency\n","\n","  # Function to find the number of activities [30,10,7,5,3] and\n","  # returns the ['Category', 'Day_ID', 'Number of Days', 'Activity Frequency', 'Frequency per Day']\n","  def activity_reverse(self,day_id,activity_frequency):\n","    counter = 0\n","    known_ID = int(day_id[2][1])\n","    activity_reverse = []\n","    for i in range(len(day_id)):\n","      if type(day_id[i][1]) == str:\n","        category = day_id[i][0] # the category\n","      elif type(day_id[i][1]) == int:\n","        if day_id[i][1] > 9:\n","          # The number of days in reverse.\n","          reverse_days = [3,5,7,10,30]\n","          # 'Day_ID' ignores the first 10 days by subtracting 10 from 'start' and 'end'.\n","          # activity_by_category = []\n","          for k in range(len(reverse_days)):\n","            # 'end' is set to the 'Day_ID' when calculating the first reverse day '3'\n","            # Otherwise, it is a subtracted 'known_ID' that is the previous 'start' value below.\n","            if reverse_days[k] == 3:\n","              end = day_id[i][1]\n","            else:\n","              end = known_ID\n","            start = day_id[i][1] - reverse_days[k]\n","            # print('start: ', start, ' = ', day_id[i][1], ' - ', reverse_days[k])\n","            # print('end: ', end)\n","            # Avoids calculating frequencies for the first 10 days.\n","            if start > 9:\n","              # The number of activities 'reverse_days[k]' from the pain observation.\n","              activity_total = 0\n","              for j in range(start-10,end-10):\n","                # Summation for the number of activities, 'reverse_days' (k) from pain observation.\n","                activity_difference = activity_frequency[j][2] - activity_frequency[j][1]\n","                # print('Activity calculating : ', activity_difference, ' = ', activity_frequency[j][2], ' - ', activity_frequency[j][1])\n","                activity_total += activity_difference\n","                counter += 1\n","              # 'known_ID' is used to avoid calculating frequencies that are already known\n","              # by using the previous start to avoid duplicated iterations.\n","              known_ID = start\n","              # If 'k' is greater than '0', the previous day range frequency difference\n","              # was already calcualted and is used to calculate the frequency, reducing\n","              # unnecessary iterations. If 'reverse_days[k]' is '5' the frequency is already\n","              # known for '3', the difference for days '4' and '5' are calculated and added\n","              # onto 'activity_previous'.\n","              if k > 0:\n","                activity_previous = activity_intermediate + activity_total\n","              else:\n","                activity_previous = activity_total\n","              # The previous total is held for the next iteration.\n","              # print('Activity Total = ', activity_previous)\n","              activity_intermediate = activity_previous\n","              # Calculate the 'Activity Frequency' and 'Days' to get the the average of each day.\n","              activity_day_mean = round(activity_previous / reverse_days[k],2)\n","              activity_reverse.append([category,day_id[i][1],reverse_days[k],activity_previous,activity_day_mean])\n","          # print(category,day_id[i][1],reverse_days[k],activity_previous)\n","          if i+1 == len(day_id):\n","            break\n","          # known_ID = day_id[i+1][1]\n","          # Avoids when the only 'reverse_days[k]' is '30' and is the only\n","          # 'start' that's less than '9'. [3,5,7,10] have already been\n","          # calculated.\n","          #if known_ID == 'NA':\n","          #  known_ID = day_id[i+2][1]\n","          #print('known ID: ', known_ID)\n","    # print(counter) # ~472 iterations without skips or 250 with skipping already calculated differences.\n","    for iter in activity_reverse:\n","      print(iter)\n","    return activity_reverse\n","\n","  # Function to find the mean for each day group [3,5,7,10,30] mean.\n","  def activity_group_mean(self,input_data):\n","    group_day = [3,5,7,10,30]\n","    group_mean_list = []\n","\n","    for i in range(len(group_day)):\n","      group_sum = 0\n","      group_count = 0\n","      for j in range(len(input_data)):\n","        # When the 'group_day' is the same as the group day value in\n","        # the 'activity_frequency' as calculate by 'Day_ID', that '3' '5', etc\n","        # group sum and count is incremented by the frequency and count respectively.\n","        if group_day[i] == input_data[j][2]:\n","          group_sum += input_data[j][4]\n","          group_count += 1\n","      # Once all the '3', '5', or ... n is summized, that group day's mean is calculated.\n","      # Subtract one because there's an extra '0' value appended from 'activity_day_mean()'.\n","      group_mean = group_sum / (group_count - 1)\n","      group_mean_list.append([round(group_mean,2),group_day[i],group_count])\n","\n","    return group_mean_list\n","\n","#################################################\n","# Part F: Non-parametric Classification Metrics #\n","#################################################\n","# Inputs are observations and prediction columns.\n","# Assumes input has a header.\n","class classification_metrics:\n","  # true_positive  = true_positive   1  (true_positive 1 / true_positive 1 + fn4) or recall\n","  # true_negative  = true_negative   0  (true_negative 0 / true_negative 0 + false_positive 3)\n","  # false_positive = false_positive  3  predicted soreness, was not sore.\n","  #                                     false positive rate = false_positive 3 / false_positive 3 + true_negative 0\n","  # false_negative = false_negative  4  predicted not soreness, was sore\n","  # https://www.geeksforgeeks.org/metrics-for-machine-learning-model/#regression-evaluation-metrics\n","  # https://developers.google.com/machine-learning/crash-course/classification/accuracy-precision-recall\n","  '''\n","  print(P1_vert[0])\n","  print(P1_vert[1])\n","  print(P1_vert[2])\n","  # 0 6 7 8\n","  print(A1_vert[0]) # Day_ID\n","  print(A1_vert[6]) # Activity\n","  # print(A1_vert[7]) # Notes\n","  # print(A1_vert[8]) # Explaination\n","  '''\n","  def __init__(self,observations,predictions):\n","    # The input scale is 5-1 high pain to low pain (or stamina).\n","    # The original data was 1-5 high pain to low pain and was flipped\n","    # since it was confusing (except for stamina).\n","    self.observations = observations\n","    self.predictions = predictions\n","\n","  def binary_classification(self):\n","    # Returns 0 (True Negative) 1 (True Positive) if prediction\n","    # matches observation. False Positive when prediction was soreness\n","    # and observation was no soreness (3). False Negative when the prediction\n","    # was no soreness and there was soreness (4).\n","    # Also returns the count for the classifications.\n","    true_negative = 0\n","    true_positive = 0\n","    false_positive = 0\n","    false_negative = 0\n","    binary = []\n","    for i in range(1,len(self.observations)):\n","      if self.observations[i] == self.predictions[i]:\n","        result = 1\n","        true_positive += 1\n","      else:\n","        if self.predictions[i] == 'NA' or self.observations[i] == 'NA':\n","          result = 0\n","        # False positive predicted 4 or 5 (high soreness) and was 1,2,3.\n","        elif int(self.predictions[i]) > 3 and int(self.observations[i]) <= 3:\n","          result = 3\n","          false_positive += 1\n","        # False negative predicted 1,2,3 (low soreness) and was 4 or 5.\n","        elif int(self.predictions[i]) <= 3 and int(self.observations[i]) > 3:\n","          result = 4\n","          false_negative += 1\n","        else:\n","          result = 0\n","          true_negative += 1\n","      binary.append(result)\n","    return [binary,true_negative,true_positive,false_positive,false_negative]\n","\n","  def accuracy(self,binary):\n","    # Number of correct predictions / total, input is False/True 0/1.\n","    count = 0\n","    for i in binary:\n","      if i == 1:\n","        count += 1\n","    total = len(binary)\n","    result = count / total\n","    return result\n","\n","  def precision(self,true_positive,false_positive):\n","    # precision = true_positive 1 / (true_positive 1 + false_positive 3)\n","    result = true_positive / (true_positive + false_positive)\n","    return result\n","\n","  def recall(self,true_positive,false_negative):\n","    # (true_positive / true_positive + false_negative 4) or recall\n","    result = true_positive / (true_positive + false_negative)\n","    return result\n","\n","  def f1_score(self,true_positive,false_positive,false_negative):\n","    # 2 * (precision * recall) / (precision + recall)\n","    # (2 true_positive) / (2 true_positive + false_positive 3 + false_negative)\n","    result = (2 * true_positive) / ((2*true_positive) + false_positive + false_negative)\n","    return result\n","\n","  # After the previous n (10,7,5,3) days of activity frequency, use the non parametric\n","  # Wilcoxon's rank sum test to compare the two dependent or paired samples. The two\n","  # samples being compared are n days activity frequency with the entire dataset's activity\n","  # frequency. It is non-parametric because it is categorical or ordinal dataset and\n","  # not real world measurements, despite having over 30 observations.\n","  # https://www.stat.purdue.edu/~tqin/system101/method/method_wilcoxon_rank_sum_sas.htm\n","  # https://pmc.ncbi.nlm.nih.gov/articles/PMC4754273/\n","  def wilcoxon_rank_sum(self):\n","    return\n","\n","##############################################################################\n","# Part Z: Run the functions                                                  #\n","##############################################################################\n","\n","# Part A: The path of the CSV to be parsed\n","def CSV_running(path,unflipped_col):\n","  # Create the CSV_Parser class object and open the files\n","  parser = eu.CSV_Parser(path)\n","  read = parser.file_opener()\n","  # Index the comma position from the CSV and split the characters into their values\n","  comma_indexed = parser.comma_index(read, path, 0)\n","  # Get the width of columns of the commas\n","  comma_width = parser.comma_index(read, path, 1)\n","  # Sort the list into verticle columns\n","  # The P0 csv gets flipped, except for the Stm column\n","  # Divide by two - the list of comma places is doubled for the start/end value\n","  col_width = int(((comma_width - 1 ) / 2) - 1)\n","  vert = []\n","  for i in range(0,comma_width-1,2):\n","    value_list = parser.csv_value_list(comma_indexed, read, col_width, i)\n","    if unflipped_col == 0:\n","      vert.append(value_list)\n","    else:\n","      if value_list[0] in unflipped_col:\n","        vert.append(value_list)\n","      else:\n","        flip = parser.csv_flipper(value_list, col_width)\n","        vert.append(flip)\n","  return vert\n","\n","# Part F: Predictions vs Observed pain values using classification metrics.\n","def P1_Classification_RGB_graph(P1_vert,P1_vert_predictions):\n","\n","  # B1.csv - Nutrition - binary calories high and low -> above/below 2500\n","  # - Mean number of activities per day over 3-14 days\n","  #     - Exclude 09/09-09/13 since it was recorded with excessive detail.\n","  # - Not stretching in the one or two days afterward.\n","  # - Stretching too frequently in the one or two days afterward.\n","\n","  # Days of Interest :\n","  # Stamina for 08/27-0903 (value 4) except 08/29 (value 2) and abs (4) on 08/31.\n","      # Stamina for 09/13. Exclude 09/09-09/13 since it was recorded with excessive detail.\n","  # Stamina for 09/19-09/22 (value 4) except 09/21 (value 2).\n","  # The goal is to find an appropriate balance for exercise and not moving\n","  # by examining the frequency of Activities before these decreases.\n","\n","  # 'Day_ID' remove 49-53 for average graphing because they were recorded\n","  # differently and induce outliers. ['909','910','911','912','913']\n","  for P1 in range(len(P1_vert_predictions)):\n","    del P1_vert_predictions[P1][50:55]\n","    del P1_vert[P1][50:55]\n","  # Remove these dates: ['909','910','911','912','913']\n","  # in A1_vert[0], A1_vert[3]\n","  del A1_vert[0][271:326]\n","  del A1_vert[3][271:326]\n","  # Accuracy, Precision, Recall, F1\n","  # Uses F1 since RMSE is for regression prediction models. The pain scale\n","  # is numerical and is equivilent to nominal categories.\n","  title_full = ['','','',\n","  'Stamina',\n","  'Feet','Ankle','Calves',\n","  'Knees','Quadriceps','Gluteus','Groin',\n","  'Abdominals','Lower Back',\n","  'Latissimus Dorsi','Trapezius','Shoulders',\n","  'Chest','Triceps','Biceps',\n","  'Neck','Head']\n","  # todo classification_metrics\n","  # wilcoxon_rank_sum\n","  for i in range(3,len(P1_vert)):\n","    '''\n","    print('Pain Scale')\n","    print(P1_vert[i])\n","    print('Classification')\n","    class_met = classification_metrics(P1_vert[i],P1_vert_predictions[i])\n","    binary = class_met.binary_classification()\n","    print(binary[0])\n","    print()\n","    # i is the pain scale 'Day_ID' (1-101) for A1 (1-350ish) 'did'\n","    print(A1_vert[0]) # 'Day_ID\n","    print(A1_vert[1])\n","    print(A1_vert[6]) # 'Activity'\n","    print()\n","    '''\n","\n","    A1_graphs_sort = eu.Graphs_sort(A1_vert)\n","    A1_filter = A1_graphs_sort.filter_stop(A1_graphs_sort.data[6])\n","\n","    '''\n","    A1_graphs_sort = Graphs_sort(data)\n","    A1_graphs_sort.filter_stop(A1_graphs_sort.data[])\n","    acc_binary = class_met.accuracy(binary[0])\n","    # header : print(P1_vert[i][0])\n","    print('Accuracy', ' = ', acc_binary)\n","    precision_binary = class_met.precision(binary[2],binary[3]) # tsp fp\n","    print('Precision', ' = ', precision_binary)\n","    print('tsp', ' ', binary[2])\n","    print('fp', ' ', binary[3])\n","    print()\n","    recall_binary = class_met.recall(binary[2],binary[4]) # tsp fn\n","    print('Recall', ' = ', recall_binary)\n","    print('tsp', ' ', binary[2])\n","    print('fp', ' ', binary[3])\n","    print()\n","    f1_score_binary = class_met.f1_score(binary[2],binary[3],binary[4]) # tsp fp fn\n","    print('F1 Score', ' = ', f1_score_binary)\n","    print('tsp', ' ', binary[2])\n","    print('fp', ' ', binary[3])\n","    print('fn', ' ', binary[4])\n","    print()\n","    print()\n","    print()\n","    '''\n","\n","  return\n","\n","def A1_daily_RGB_graph(P1_vert,P1_vert_predictions,A1_vert):\n","  # Edited five days to remove overly detailed entries called 'A1-small.csv'\n","  # original is 'A1.csv' - ['909','910','911','912','913']\n","\n","  A1_Graphs_sort = Graphs_sort(A1_vert)\n","  days_pain = []\n","  days_not_pain = []\n","  all_days = []\n","  # Loop returns the bodily part, number of days, and erroneous pain or\n","  # stamina values start and end from the erroneous observation minus\n","  # number of days. Also returns the days that were not a pain.\n","  for i in P1_vert[3:]:\n","    reverse_days = A1_Graphs_sort.erroneous_values(i)\n","    if len(reverse_days[0]) > 2:\n","      days_pain += reverse_days[0]\n","      days_not_pain += reverse_days[1]\n","      all_days += reverse_days[2]\n","\n","  # Returns the frequency of activities for every day (discards the first 10).\n","  A1_activity_splice = A1_Graphs_sort.activity_frequency_splice()\n","  A1_activity_pain = A1_Graphs_sort.activity_reverse(days_pain,A1_activity_splice)\n","  #A1_activity_not_pain = A1_Graphs_sort.activity_reverse(days_not_pain,A1_activity_splice)\n","  #A1_activity_all = A1_Graphs_sort.activity_reverse(all_days,A1_activity_splice)\n","\n","  # Calcualtes the mean for each reverse day means, then graph '3' on x with the sum\n","  # of the erroneous means divided by their count on the y against non pain\n","  # means and all the days mean. 'y' is labeled 'Activity Frequency'.\n","  #A1_pain_group_mean = A1_Graphs_sort.activity_group_mean(A1_activity_pain)\n","  #A1_not_pain_group_mean = A1_Graphs_sort.activity_group_mean(A1_activity_not_pain)\n","  #A1_all_group_mean = A1_Graphs_sort.activity_group_mean(A1_activity_all)\n","\n","  # Graphing section.\n","  # Summarized pain, not pain, and all data means for 3,5,7,10,and 30 days before the event.\n","  A1_graph_rgb = Graphs_rgb([])\n","  # A1_reverse_mean_category = A1_graph_rgb.rgb_reverse_category(A1_pain_group_mean,A1_not_pain_group_mean,A1_all_group_mean)\n","\n","  # Mean of every reverse splice for each day.\n","  A1_day_mean_category = A1_graph_rgb.rgb_reverse_day_mean(A1_activity_pain,P1_vert_predictions)\n","\n","  # Graphing the prediction and observation along with classification metrics.\n","  # Usage is from 'P1_Classification_RGB_graph()'\n","  title_full = [#'','','',\n","  'Stamina',\n","  'Feet','Ankle','Calves',\n","  'Knees','Quadriceps','Gluteus','Groin',\n","  'Abdominals','Lower Back',\n","  'Latissimus Dorsi','Trapezius','Shoulders',\n","  'Chest','Triceps','Biceps',\n","  'Neck','Head']\n","  for j in range(3,len(P1_vert_predictions)):\n","    class_met = classification_metrics(P1_vert[j],P1_vert_predictions[j])\n","    binary = class_met.binary_classification()\n","    acc_binary = class_met.accuracy(binary[0])\n","    precision_binary = class_met.precision(binary[2],binary[3]) # tsp fp\n","    recall_binary = class_met.recall(binary[2],binary[4]) # tsp fn\n","    f1_score_binary = class_met.f1_score(binary[2],binary[3],binary[4]) # tsp fp fn\n","    classification_list = [title_full[j-3],P1_vert[j][0],acc_binary,precision_binary,recall_binary,f1_score_binary]\n","    # P1_graph_rgb = Graphs_rgb([])\n","    # P1_graph_rgb.rgb_prediction_observation(P1_vert_predictions[j],P1_vert[j],P1_vert_predictions[1],classification_list)\n","  return\n","\n","# One month of May, 2024 observations\n","P0_path = \"/content/P0.csv\"\n","B0_path = \"/content/B0.csv\"\n","# A0 is a TSV because there are blank cells\n","A0_path = \"/content/A0.tsv\"\n","P0_unflipped_col = ['ID','Date','Day','Stm']\n","# P0_vert = CSV_running(P0_path,P0_unflipped_col)\n","# B0_vert = CSV_running(B0_path,0)\n","# A0_vert = CSV_running(A0_path,0)\n","# Four months of July-October observations\n","# P1.csv contains the pain scale and B1.csv contains the food records\n","P1_path = \"/content/P1-Observations-PaperFigures.csv\"\n","P1_path_predictions = \"/content/P1-Prediction-PaperFigures.csv\"\n","# B1_path = \"/content/B1.csv\"\n","# A1 is a tsv because of blank cells\n","# A1_path = \"/content/A1.tsv\" # The full dataset.\n","A1_path = \"/content/A1-small.tsv\"\n","# List of columns to not be flipepd\n","P1_unflipped_col = ['ID','Date','Day','Stm','Notes','Notes2']\n","P1_vert = CSV_running(P1_path,P1_unflipped_col)\n","P1_vert_predictions = CSV_running(P1_path_predictions,P1_unflipped_col)\n","# B1_vert = CSV_running(B1_path,0)\n","A1_vert = CSV_running(A1_path,0)\n","\n","# P1_RGB_graph(P1_vert)\n","# B1_RGB_graph(B1_vert)\n","# A0_RGB_graph(A0_vert)\n","# A1_RGB_graph(A1_vert)\n","# P1_Classification_RGB_graph(P1_vert,P1_vert_predictions)\n","A1_daily_RGB_graph(P1_vert,P1_vert_predictions,A1_vert)"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":36},"executionInfo":{"elapsed":8,"status":"ok","timestamp":1749480169036,"user":{"displayName":"David Leifer","userId":"06279506333224389759"},"user_tz":300},"id":"nyadd2nCLeqQ","outputId":"a002dbcf-d792-4966-9e49-b2f262e8c999"},"outputs":[{"data":{"application/vnd.google.colaboratory.intrinsic+json":{"type":"string"},"text/plain":["\"\\nfor i in range(1,len(a)):\\n  print(a[:i])\\n  print(a[i])\\n  print('zzzzz')\\n\\n  print(a[-1])\""]},"execution_count":6,"metadata":{},"output_type":"execute_result"}],"source":["######|### |a = 'abcdefg'\n","'''\n","for i in range(1,len(a)):\n","  print(a[:i])\n","  print(a[i])\n","  print('zzzzz')\n","\n","  print(a[-1])'''"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":6,"status":"ok","timestamp":1744137032714,"user":{"displayName":"David Leifer","userId":"06279506333224389759"},"user_tz":300},"id":"SLyAYj_xtzdg","outputId":"3bb4744a-366f-4183-a0ca-7f695d31af9e"},"outputs":[{"name":"stdout","output_type":"stream","text":["[[[1], ['b']]]\n"]}],"source":["abc = [\n","        [[0], ['a']],\n","        [[1], ['b']],\n","        [[2], ['c']],\n","        [[3], ['d']],\n","        [[4], ['e']],\n","        [[5], ['f']],\n","        [[6], ['g']],\n","        [[7], ['h']],\n","        [[8], ['i']],\n","        [[9], ['j']],\n","                      ]\n","# for i in range(10):\n","print(abc[1:2])"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":9,"status":"ok","timestamp":1744769169351,"user":{"displayName":"David Leifer","userId":"06279506333224389759"},"user_tz":300},"id":"kti4uK-eVPeZ","outputId":"1c1bc210-f9b0-4b10-b49e-62551d97b986"},"outputs":[{"name":"stdout","output_type":"stream","text":["34\n","5\n"]}],"source":["a = '1234'\n","b = '567'\n","c = '89'\n","\n","\n","if len(a) == 4:\n","  end_sub = a[2:]\n","  print(end_sub)\n","\n","if len(b) == 3:\n","  end_sub = b[:1]\n","  print(end_sub)\n","\n","if len(c) == 2:\n","  end_sub = c"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"bNU5wcEd0AeC"},"outputs":[],"source":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"6wounMFJaZT3"},"outputs":[],"source":[]}],"metadata":{"colab":{"provenance":[{"file_id":"1fHIWbrpk4NMYcse3Xdkb-S8XiS2pxzJm","timestamp":1721260308720},{"file_id":"1STKhtVVaknUZiohwWLdfyoZ3zg6Veimx","timestamp":1721260179755}],"authorship_tag":"ABX9TyMu1bnRHtzGxtmQ+CyhZcP1"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}